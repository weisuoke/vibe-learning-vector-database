# Docker 基本命令：pull, run, ps, stop, rm

---

## 1. 【30字核心】

**Docker 基本命令是操作容器生命周期的核心工具：pull 获取镜像，run 启动容器，ps 查看状态，stop/rm 管理生命周期。**

---

## 2. 【第一性原理】

### 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

### Docker 命令的第一性原理 🎯

#### 1. 最基础的定义

**Docker 命令 = 对镜像和容器的增删改查操作**

仅此而已！所有命令都可以归类为：
- 对**镜像**的操作：pull（下载）、images（查看）、rmi（删除）
- 对**容器**的操作：run（创建并运行）、ps（查看）、stop（停止）、rm（删除）

#### 2. 为什么需要这些命令？

**核心问题：如何管理容器的完整生命周期？**

容器生命周期：
```
获取镜像 → 创建容器 → 启动运行 → 查看状态 → 停止 → 删除
  pull        run        run        ps       stop     rm
```

#### 3. Docker 命令的三层价值

##### 价值1：标准化操作
所有 Docker 环境使用相同的命令，一次学会，到处能用。

##### 价值2：自动化基础
```bash
# 脚本自动化部署
docker pull milvusdb/milvus:latest
docker stop old-milvus || true
docker rm old-milvus || true
docker run -d --name new-milvus milvusdb/milvus:latest
```

##### 价值3：声明式思维
告诉 Docker "我要什么"，而不是"怎么做"。

#### 4. 从第一性原理推导命令体系

**推理链：**
```
1. 需要运行软件
   ↓
2. 软件需要先获取（pull）
   ↓
3. 获取后需要运行（run）
   ↓
4. 运行后需要监控状态（ps）
   ↓
5. 不需要时要停止（stop）
   ↓
6. 清理资源要删除（rm）
   ↓
7. 形成完整的生命周期管理
```

#### 5. 一句话总结第一性原理

**Docker 命令是对容器生命周期的声明式控制，掌握 5 个核心命令就能完成 90% 的日常操作。**

---

## 3. 【3个核心概念】

### 核心概念1：docker pull - 获取镜像 📥

**从远程仓库下载镜像到本地。**

```bash
# 基本语法
docker pull <镜像名>:<标签>

# 拉取最新版本（默认 latest 标签）
docker pull nginx

# 拉取指定版本
docker pull python:3.9

# 拉取向量数据库镜像
docker pull milvusdb/milvus:v2.3.0
docker pull qdrant/qdrant:v1.6.0
```

**详细解释：**
- 镜像名格式：`[仓库地址/]用户名/镜像名:标签`
- 省略仓库地址默认使用 Docker Hub
- 省略标签默认使用 `latest`

**在向量数据库中的应用：**
```bash
# 生产环境建议指定具体版本，避免意外更新
docker pull milvusdb/milvus:v2.3.0
```

---

### 核心概念2：docker run - 创建并运行容器 🚀

**从镜像创建容器并启动运行，这是最重要的命令。**

```bash
# 基本语法
docker run [选项] <镜像名> [命令]

# 最简单的运行
docker run nginx

# 常用选项组合
docker run -d --name my-nginx -p 8080:80 nginx
```

**核心选项详解：**

| 选项 | 含义 | 示例 |
|------|------|------|
| `-d` | 后台运行（detached） | `docker run -d nginx` |
| `--name` | 指定容器名称 | `--name my-nginx` |
| `-p` | 端口映射 | `-p 8080:80` |
| `-v` | 挂载数据卷 | `-v /host:/container` |
| `-e` | 设置环境变量 | `-e MYSQL_ROOT_PASSWORD=123` |
| `--rm` | 容器停止后自动删除 | `docker run --rm nginx` |
| `-it` | 交互式终端 | `docker run -it ubuntu bash` |

**在向量数据库中的应用：**
```bash
# 启动 Qdrant（开发环境推荐）
docker run -d \
  --name qdrant \
  -p 6333:6333 \
  -v $(pwd)/qdrant_data:/qdrant/storage \
  qdrant/qdrant

# 启动 Milvus Standalone（学习测试用）
docker run -d \
  --name milvus-standalone \
  -p 19530:19530 \
  -p 9091:9091 \
  -v $(pwd)/milvus_data:/var/lib/milvus \
  milvusdb/milvus:latest \
  milvus run standalone
```

---

### 核心概念3：docker ps - 查看容器状态 👀

**列出正在运行的容器（加 -a 查看所有容器）。**

```bash
# 查看运行中的容器
docker ps

# 查看所有容器（包括已停止的）
docker ps -a

# 只显示容器 ID
docker ps -q

# 格式化输出
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
```

**输出字段解释：**
```
CONTAINER ID   IMAGE           COMMAND       CREATED        STATUS        PORTS                    NAMES
a1b2c3d4e5f6   qdrant/qdrant   "./qdrant"    5 minutes ago  Up 5 minutes  0.0.0.0:6333->6333/tcp   qdrant
```

| 字段 | 含义 |
|------|------|
| CONTAINER ID | 容器唯一标识（短格式） |
| IMAGE | 使用的镜像 |
| COMMAND | 容器启动命令 |
| CREATED | 创建时间 |
| STATUS | 运行状态 |
| PORTS | 端口映射 |
| NAMES | 容器名称 |

**在向量数据库中的应用：**
```bash
# 快速检查向量数据库是否正常运行
docker ps | grep -E "milvus|qdrant|weaviate"
```

---

## 4. 【最小可用】

掌握以下内容，就能管理 Docker 容器：

### 4.1 五个核心命令速记

```bash
# 1. 获取镜像
docker pull <镜像>

# 2. 运行容器
docker run -d --name <名称> -p <端口映射> <镜像>

# 3. 查看容器
docker ps        # 运行中
docker ps -a     # 所有

# 4. 停止容器
docker stop <容器名或ID>

# 5. 删除容器
docker rm <容器名或ID>
```

### 4.2 一个完整的工作流示例

```bash
# 场景：启动 Qdrant 向量数据库进行开发

# Step 1: 拉取镜像
docker pull qdrant/qdrant

# Step 2: 启动容器
docker run -d --name qdrant -p 6333:6333 qdrant/qdrant

# Step 3: 验证运行状态
docker ps

# Step 4: 开发测试...

# Step 5: 停止容器
docker stop qdrant

# Step 6: 下次继续使用
docker start qdrant

# Step 7: 不再需要，清理
docker stop qdrant
docker rm qdrant
```

### 4.3 常用组合命令

```bash
# 停止并删除所有容器
docker stop $(docker ps -q) && docker rm $(docker ps -aq)

# 删除所有未使用的镜像
docker image prune -a

# 一键清理（慎用）
docker system prune -a
```

**这些知识足以：**
- 完成日常的容器启动和停止
- 管理开发环境的向量数据库
- 排查容器运行问题

---

## 5. 【1个类比】

### 类比1：docker pull = npm install 📦

**相似性：** 都是从远程仓库获取依赖

```bash
# 前端
npm install express@4.18.0  # 从 npm 获取指定版本

# Docker  
docker pull nginx:1.25      # 从 Docker Hub 获取指定版本
```

---

### 类比2：docker run = npm start/node xxx.js 🏃

**相似性：** 都是启动程序运行

```bash
# 前端启动开发服务器
npm run dev
# 或
node server.js

# Docker 启动容器
docker run nginx
# 或带参数
docker run -d -p 80:80 nginx
```

**选项类比：**
```javascript
// Node.js 指定端口
node server.js --port=3000

// Docker 指定端口
docker run -p 3000:80 nginx
```

---

### 类比3：docker ps = ps aux / Activity Monitor 📊

**相似性：** 都是查看进程状态

```bash
# 系统进程查看
ps aux | grep node

# Docker 容器查看
docker ps | grep nginx
```

| 系统命令 | Docker 命令 | 作用 |
|----------|-------------|------|
| `ps aux` | `docker ps` | 查看运行中的 |
| `ps aux -a` | `docker ps -a` | 查看所有 |
| `top` | `docker stats` | 实时资源监控 |

---

### 类比4：docker stop = Ctrl+C / kill 进程 ⏹️

**相似性：** 都是停止正在运行的程序

```bash
# 停止 Node 进程
kill <pid>
# 或在终端按 Ctrl+C

# 停止 Docker 容器
docker stop my-container

# 强制停止（类似 kill -9）
docker kill my-container
```

---

### 类比5：docker rm = rm -rf node_modules 🗑️

**相似性：** 都是删除不需要的东西

```bash
# 删除 node_modules
rm -rf node_modules

# 删除容器
docker rm my-container

# 删除镜像（类似删除 npm 缓存）
docker rmi nginx
```

---

### 类比总结表

| 前端/系统操作 | Docker 命令 | 作用 |
|---------------|-------------|------|
| `npm install` | `docker pull` | 获取依赖/镜像 |
| `npm start` | `docker run` | 启动运行 |
| `ps aux` | `docker ps` | 查看进程/容器 |
| `Ctrl+C` / `kill` | `docker stop` | 停止运行 |
| `rm -rf` | `docker rm` | 删除清理 |
| `npm cache clean` | `docker system prune` | 清理缓存 |

---

## 6. 【反直觉点】

### 误区1：docker run 每次都创建新容器 ❌

**为什么错？**
- `docker run` = `docker create` + `docker start`
- 每次 `run` 确实会创建**新**容器
- 想重启已有容器应该用 `docker start`

**为什么人们容易这样错？**
习惯了 `npm start` 这种"启动"语义，以为 `run` 是启动已有的。

**正确理解：**
```bash
# 第一次：创建并运行
docker run -d --name my-nginx nginx
# 创建了容器 "my-nginx"

# 错误：再次 run
docker run -d --name my-nginx nginx
# 报错：容器名已存在！

# 正确：重启已有容器
docker start my-nginx
```

**命令区分：**
| 命令 | 作用 | 场景 |
|------|------|------|
| `docker run` | 创建新容器并运行 | 第一次使用镜像 |
| `docker start` | 启动已停止的容器 | 重启已有容器 |
| `docker restart` | 重启运行中的容器 | 容器需要重启 |

---

### 误区2：-p 8080:80 的顺序搞反 ❌

**为什么错？**
- 正确顺序：`-p 宿主机端口:容器端口`
- 记忆方法：**外:内**，从外面访问的端口在前

**为什么人们容易这样错？**
没有固定的记忆规律，两个数字容易混淆。

**正确理解：**
```bash
# 宿主机 8080 → 容器 80
docker run -p 8080:80 nginx

# 访问方式
curl http://localhost:8080  # ✅ 用宿主机端口
curl http://localhost:80    # ❌ 这是容器内部端口

# 记忆口诀：
# "我在外面用8080，它在里面听80"
# "外:内"
```

**可视化理解：**
```
你的电脑（宿主机）          Docker 容器
    │                          │
    │  localhost:8080    ──→   │ :80
    │                          │
    └──────────────────────────┘
          -p 8080:80
```

---

### 误区3：删除容器就删除了数据 ❌

**为什么错？**
- 删除容器确实会丢失**容器内**的数据
- 但使用**数据卷**（-v）挂载的数据不会丢失
- 正确做法：重要数据一定要用数据卷

**为什么人们容易这样错？**
不了解 Docker 的数据持久化机制。

**正确理解：**
```bash
# 错误：数据在容器内，删除后丢失
docker run -d --name db mysql
docker rm db  # 数据库数据全没了！

# 正确：使用数据卷持久化
docker run -d --name db \
  -v /my/data:/var/lib/mysql \
  mysql
docker rm db  # 数据仍在 /my/data 目录

# 向量数据库的正确用法
docker run -d --name qdrant \
  -v $(pwd)/qdrant_storage:/qdrant/storage \
  qdrant/qdrant
# 删除容器后，向量数据仍然保留
```

---

## 7. 【实战代码】

```bash
#!/bin/bash
# Docker 基本命令实战演示
# 场景：管理向量数据库容器的完整生命周期

echo "===== Docker 基本命令实战 ====="

# ===== 1. 环境检查 =====
echo ""
echo "=== 1. 环境检查 ==="
docker --version
echo "当前运行的容器："
docker ps --format "table {{.Names}}\t{{.Status}}"

# ===== 2. 拉取镜像 =====
echo ""
echo "=== 2. 拉取 Qdrant 镜像 ==="
docker pull qdrant/qdrant:latest
echo "镜像大小："
docker images qdrant/qdrant --format "{{.Repository}}:{{.Tag}} - {{.Size}}"

# ===== 3. 运行容器（基础版） =====
echo ""
echo "=== 3. 启动 Qdrant 容器 ==="
docker run -d \
  --name qdrant-basic \
  -p 6333:6333 \
  qdrant/qdrant
echo "容器已启动"

# ===== 4. 查看容器状态 =====
echo ""
echo "=== 4. 查看容器状态 ==="
echo "运行中的容器："
docker ps --filter "name=qdrant"

echo ""
echo "容器详细信息："
docker inspect qdrant-basic --format '{{.State.Status}} - {{.NetworkSettings.IPAddress}}'

# ===== 5. 查看容器日志 =====
echo ""
echo "=== 5. 查看容器日志（最后5行）==="
sleep 2  # 等待容器启动
docker logs qdrant-basic --tail 5

# ===== 6. 测试服务是否正常 =====
echo ""
echo "=== 6. 测试 Qdrant API ==="
curl -s http://localhost:6333/collections | python3 -m json.tool 2>/dev/null || echo "API 响应正常"

# ===== 7. 进入容器执行命令 =====
echo ""
echo "=== 7. 在容器内执行命令 ==="
docker exec qdrant-basic ls /qdrant

# ===== 8. 停止容器 =====
echo ""
echo "=== 8. 停止容器 ==="
docker stop qdrant-basic
echo "容器状态："
docker ps -a --filter "name=qdrant-basic" --format "{{.Names}}: {{.Status}}"

# ===== 9. 重新启动容器 =====
echo ""
echo "=== 9. 重新启动容器 ==="
docker start qdrant-basic
echo "容器状态："
docker ps --filter "name=qdrant-basic" --format "{{.Names}}: {{.Status}}"

# ===== 10. 清理环境 =====
echo ""
echo "=== 10. 清理环境 ==="
docker stop qdrant-basic
docker rm qdrant-basic
echo "清理完成，验证："
docker ps -a --filter "name=qdrant-basic"

# ===== 11. 带数据卷的完整示例 =====
echo ""
echo "=== 11. 生产级启动（带数据卷）==="
mkdir -p ./qdrant_data

docker run -d \
  --name qdrant-prod \
  -p 6333:6333 \
  -p 6334:6334 \
  -v $(pwd)/qdrant_data:/qdrant/storage \
  --restart unless-stopped \
  qdrant/qdrant

echo "生产级容器已启动"
docker ps --filter "name=qdrant-prod" --format "table {{.Names}}\t{{.Ports}}\t{{.Status}}"

# 清理演示环境
echo ""
echo "=== 清理演示环境 ==="
docker stop qdrant-prod
docker rm qdrant-prod
rm -rf ./qdrant_data

echo ""
echo "===== 实战演示完成 ====="
```

**运行输出示例：**
```
===== Docker 基本命令实战 =====

=== 1. 环境检查 ===
Docker version 24.0.7, build afdd53b
当前运行的容器：
NAMES              STATUS

=== 2. 拉取 Qdrant 镜像 ===
latest: Pulling from qdrant/qdrant
Status: Image is up to date for qdrant/qdrant:latest
镜像大小：
qdrant/qdrant:latest - 180MB

=== 3. 启动 Qdrant 容器 ===
a1b2c3d4e5f6...
容器已启动

=== 4. 查看容器状态 ===
运行中的容器：
CONTAINER ID   IMAGE           STATUS         PORTS                    NAMES
a1b2c3d4e5f6   qdrant/qdrant   Up 2 seconds   0.0.0.0:6333->6333/tcp   qdrant-basic

=== 5. 查看容器日志（最后5行）===
[INFO] Qdrant is ready to serve
[INFO] Starting web API at 0.0.0.0:6333

=== 6. 测试 Qdrant API ===
{
    "result": {
        "collections": []
    },
    "status": "ok"
}

===== 实战演示完成 =====
```

---

## 8. 【面试必问】

### 问题："docker run 和 docker start 有什么区别？"

**普通回答（❌ 不出彩）：**
"run 是运行容器，start 是启动容器。"

**出彩回答（✅ 推荐）：**

> **两个命令的核心区别在于是否创建新容器：**
>
> 1. **docker run**：从镜像**创建**一个新容器，然后启动它
>    - 等价于 `docker create` + `docker start`
>    - 每次执行都会创建新的容器实例
>    - 常用于第一次运行某个镜像
>
> 2. **docker start**：启动一个**已存在**但已停止的容器
>    - 不创建新容器
>    - 保留之前容器的所有状态和数据
>    - 常用于重启之前的工作环境
>
> **实际工作中的最佳实践：**
> ```bash
> # 首次运行（会创建新容器）
> docker run -d --name my-db postgres
> 
> # 之后重启（复用已有容器）
> docker start my-db
> ```
>
> **这样做的好处是：** 容器内的数据和配置变更都会保留，不会每次都从头开始。在部署向量数据库时，这一点尤其重要，因为重建索引很耗时。

**为什么这个回答出彩？**
1. ✅ 点明本质区别：是否创建新容器
2. ✅ 说明等价关系：run = create + start
3. ✅ 给出实际使用场景
4. ✅ 结合向量数据库的具体应用

---

## 9. 【化骨绵掌】

### 卡片1：docker pull - 购物 🛒

**一句话：** pull 就是从 Docker 超市下载商品（镜像）。

**举例：**
```bash
docker pull nginx           # 下载 nginx
docker pull python:3.9      # 下载指定版本
```

**应用：** `docker pull milvusdb/milvus` 下载向量数据库。

---

### 卡片2：docker run - 开箱运行 📦

**一句话：** run = 创建容器 + 启动，是最常用的命令。

**举例：**
```bash
docker run -d --name web nginx
# -d 后台运行
# --name 指定名称
```

**应用：** 一键启动 Qdrant 向量数据库。

---

### 卡片3：docker ps - 查看状态 👀

**一句话：** ps 显示容器的"花名册"。

**举例：**
```bash
docker ps      # 运行中的
docker ps -a   # 所有的（包括停止的）
```

**应用：** 排查服务是否正常运行。

---

### 卡片4：docker stop - 优雅停止 ⏸️

**一句话：** stop 发送停止信号，等待容器自己退出。

**举例：**
```bash
docker stop my-container    # 等待10秒后强制停止
docker stop -t 30 my-db     # 等待30秒（数据库需要更多时间）
```

**应用：** 安全停止向量数据库，保证数据完整。

---

### 卡片5：docker rm - 删除容器 🗑️

**一句话：** rm 删除已停止的容器，释放资源。

**举例：**
```bash
docker rm my-container      # 删除单个
docker rm $(docker ps -aq)  # 删除所有停止的
```

**应用：** 清理测试环境的旧容器。

---

### 卡片6：run vs start 的区别 🔄

**一句话：** run 创建新容器，start 重启旧容器。

**举例：**
```bash
# 首次
docker run --name db mysql
# 之后
docker start db  # 不会丢失数据
```

**应用：** 保留向量数据库的索引数据。

---

### 卡片7：-d 后台运行 🌙

**一句话：** -d（detached）让容器在后台运行，不占用终端。

**举例：**
```bash
docker run nginx      # 占用终端
docker run -d nginx   # 后台运行，立即返回
```

**应用：** 生产环境必须用 -d。

---

### 卡片8：--name 命名的重要性 🏷️

**一句话：** 给容器起名字，方便后续操作。

**举例：**
```bash
docker run -d --name qdrant qdrant/qdrant
docker logs qdrant    # 用名字操作
docker stop qdrant    # 比用ID方便
```

**应用：** 规范命名让运维更轻松。

---

### 卡片9：组合命令技巧 ⚡

**一句话：** 组合命令可以批量操作。

**举例：**
```bash
# 停止所有容器
docker stop $(docker ps -q)

# 删除所有容器
docker rm $(docker ps -aq)
```

**应用：** 快速清理测试环境。

---

### 卡片10：查看日志 docker logs 📋

**一句话：** logs 是排查问题的第一步。

**举例：**
```bash
docker logs my-container        # 查看全部
docker logs -f my-container     # 实时跟踪
docker logs --tail 100 my-container  # 最后100行
```

**应用：** 排查向量数据库启动失败的原因。

---

## 10. 【一句话总结】

**Docker 基本命令（pull/run/ps/stop/rm）构成了容器生命周期管理的核心操作，掌握这 5 个命令就能完成向量数据库的获取、启动、监控和清理全流程。**

---

## 📚 学习检查清单

- [ ] 能说出 pull/run/ps/stop/rm 五个命令的作用
- [ ] 理解 docker run 和 docker start 的区别
- [ ] 知道 `-d`、`--name`、`-p` 选项的含义
- [ ] 能用 docker ps 查看容器状态
- [ ] 能完成一个向量数据库容器的完整生命周期管理

## 🔗 下一步学习

- [03_端口映射与数据卷.md](./03_端口映射与数据卷.md) - 深入理解 -p 和 -v 参数
- [04_docker-compose基础用法.md](./04_docker-compose基础用法.md) - 多容器编排

## 📖 命令速查表

| 命令 | 作用 | 常用选项 |
|------|------|----------|
| `docker pull <镜像>` | 下载镜像 | 无 |
| `docker run <镜像>` | 创建并运行容器 | `-d`, `--name`, `-p`, `-v` |
| `docker ps` | 查看容器 | `-a`, `-q` |
| `docker stop <容器>` | 停止容器 | `-t` |
| `docker rm <容器>` | 删除容器 | `-f` |
| `docker start <容器>` | 启动已有容器 | 无 |
| `docker logs <容器>` | 查看日志 | `-f`, `--tail` |
| `docker exec <容器>` | 进入容器 | `-it` |

---

**版本：** v1.0  
**最后更新：** 2025-12-05
