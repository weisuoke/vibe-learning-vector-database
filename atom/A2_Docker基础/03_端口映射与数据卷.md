# 端口映射与数据卷

---

## 1. 【30字核心】

**端口映射（-p）让外部能访问容器服务，数据卷（-v）让容器数据持久化保存，两者是容器化部署的必备配置。**

---

## 2. 【第一性原理】

### 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

### 端口映射与数据卷的第一性原理 🎯

#### 1. 最基础的定义

**端口映射 = 打通容器与外部世界的网络通道**
**数据卷 = 打通容器与宿主机的文件系统通道**

仅此而已！

- 容器默认是**隔离**的：网络隔离、文件系统隔离
- 端口映射和数据卷就是在隔离墙上"开门"

#### 2. 为什么需要它们？

**核心问题1：容器里的服务，外面怎么访问？**
```
用户浏览器 → ??? → 容器内的 Nginx (80端口)
```
答案：端口映射

**核心问题2：容器删除后，数据怎么保留？**
```
容器内的数据库 → 删除容器 → 数据全没了？
```
答案：数据卷

#### 3. 两者的三层价值

##### 端口映射的价值
| 价值 | 说明 |
|------|------|
| 服务可访问 | 外部可以访问容器内的服务 |
| 端口灵活 | 宿主机端口可以与容器端口不同 |
| 多实例支持 | 同一镜像可以映射到不同端口 |

##### 数据卷的价值
| 价值 | 说明 |
|------|------|
| 数据持久化 | 容器删除后数据依然保留 |
| 数据共享 | 多个容器可以共享同一数据 |
| 性能优化 | 直接读写宿主机文件系统，性能更好 |

#### 4. 从第一性原理推导向量数据库部署

**推理链：**
```
1. 向量数据库需要被应用程序访问
   ↓
2. 应用程序在容器外部（或其他容器）
   ↓
3. 需要端口映射暴露服务端口
   ↓
4. 向量索引是宝贵的计算结果，不能丢失
   ↓
5. 需要数据卷持久化存储
   ↓
6. 正确配置后，容器可以安全地重启、更新、删除
```

#### 5. 一句话总结第一性原理

**端口映射解决"访问"问题，数据卷解决"持久化"问题，两者让容器从"玩具"变成"生产工具"。**

---

## 3. 【3个核心概念】

### 核心概念1：端口映射（Port Mapping）🔌

**将宿主机端口与容器端口建立映射关系，使外部请求能到达容器内服务。**

```bash
# 基本语法
docker run -p <宿主机端口>:<容器端口> <镜像>

# 示例：将宿主机8080映射到容器80
docker run -p 8080:80 nginx
# 访问 http://localhost:8080 → 容器内的 80 端口

# 映射多个端口
docker run -p 8080:80 -p 443:443 nginx

# 指定 IP 绑定（只允许本机访问）
docker run -p 127.0.0.1:8080:80 nginx

# 随机宿主机端口
docker run -p 80 nginx  # 系统自动分配宿主机端口
```

**详细解释：**
```
外部请求流程：
用户 → localhost:8080 → Docker → 容器:80 → Nginx

                    宿主机                     容器
┌─────────────────────────────┐    ┌─────────────────┐
│                             │    │                 │
│  用户访问 localhost:8080    │───>│  Nginx 监听 80  │
│                             │    │                 │
└─────────────────────────────┘    └─────────────────┘
            -p 8080:80
```

**在向量数据库中的应用：**
```bash
# Qdrant 默认端口
docker run -p 6333:6333 -p 6334:6334 qdrant/qdrant
# 6333: REST API
# 6334: gRPC API

# Milvus 默认端口
docker run -p 19530:19530 -p 9091:9091 milvusdb/milvus
# 19530: gRPC 服务端口
# 9091: 健康检查/metrics 端口
```

---

### 核心概念2：数据卷（Volume）💾

**将宿主机目录或 Docker 管理的卷挂载到容器内，实现数据持久化。**

```bash
# 方式1：绑定挂载（Bind Mount）- 指定宿主机路径
docker run -v /宿主机路径:/容器路径 <镜像>

# 示例：将当前目录挂载到容器
docker run -v $(pwd)/data:/app/data nginx

# 方式2：命名卷（Named Volume）- Docker 管理
docker run -v my-data:/app/data nginx

# 只读挂载
docker run -v $(pwd)/config:/app/config:ro nginx
```

**两种方式对比：**
| 特性 | 绑定挂载 | 命名卷 |
|------|----------|--------|
| 路径指定 | 完整宿主机路径 | 只写卷名 |
| 位置 | 任意目录 | Docker 管理目录 |
| 可移植性 | 较差（路径依赖） | 较好 |
| 使用场景 | 开发环境、配置文件 | 生产环境、数据存储 |

**在向量数据库中的应用：**
```bash
# Qdrant 数据持久化
docker run -d \
  -v $(pwd)/qdrant_storage:/qdrant/storage \
  qdrant/qdrant

# Milvus 数据持久化
docker run -d \
  -v $(pwd)/milvus_data:/var/lib/milvus \
  milvusdb/milvus
```

---

### 核心概念3：端口与卷的组合使用 🔗

**生产环境通常需要同时配置端口映射和数据卷。**

```bash
# 完整的向量数据库部署命令
docker run -d \
  --name qdrant-prod \
  -p 6333:6333 \
  -p 6334:6334 \
  -v $(pwd)/qdrant_storage:/qdrant/storage \
  -v $(pwd)/qdrant_config:/qdrant/config \
  --restart unless-stopped \
  qdrant/qdrant
```

**参数解析：**
```bash
-d                    # 后台运行
--name qdrant-prod    # 容器名称
-p 6333:6333          # REST API 端口
-p 6334:6334          # gRPC 端口
-v .../storage        # 数据持久化
-v .../config         # 配置文件持久化
--restart unless-stopped  # 自动重启策略
```

**在向量数据库中的应用：**
数据卷保证了向量索引的持久化，即使容器重启或更新，已建立的索引也不会丢失。

---

## 4. 【最小可用】

掌握以下内容，就能正确配置容器的网络和存储：

### 4.1 端口映射记忆口诀

```bash
# 口诀：外:内，左外右内
docker run -p 外部端口:内部端口 镜像

# 示例
docker run -p 8080:80 nginx
#           ↑    ↑
#          外部  内部
```

### 4.2 数据卷记忆口诀

```bash
# 口诀：主:客，宿主机在前
docker run -v 宿主机路径:容器路径 镜像

# 示例
docker run -v /my/data:/app/data nginx
#            ↑         ↑
#          宿主机     容器
```

### 4.3 向量数据库标准部署模板

```bash
# Qdrant 标准部署
docker run -d \
  --name qdrant \
  -p 6333:6333 \
  -v $(pwd)/qdrant_data:/qdrant/storage \
  qdrant/qdrant

# Milvus 标准部署（单机版）
docker run -d \
  --name milvus \
  -p 19530:19530 \
  -v $(pwd)/milvus_data:/var/lib/milvus \
  milvusdb/milvus:latest \
  milvus run standalone

# Chroma 标准部署
docker run -d \
  --name chroma \
  -p 8000:8000 \
  -v $(pwd)/chroma_data:/chroma/chroma \
  chromadb/chroma
```

### 4.4 常用端口参考表

| 向量数据库 | 默认端口 | 用途 |
|-----------|----------|------|
| Qdrant | 6333 | REST API |
| Qdrant | 6334 | gRPC |
| Milvus | 19530 | gRPC |
| Milvus | 9091 | Health/Metrics |
| Chroma | 8000 | HTTP API |
| Weaviate | 8080 | HTTP API |

**这些知识足以：**
- 正确暴露向量数据库的服务端口
- 持久化保存向量索引数据
- 配置生产级的容器部署

---

## 5. 【1个类比】

### 类比1：端口映射 = 公司前台转接电话 📞

**相似性：** 外部拨打公司总机，前台转接到分机

```
客户拨打：400-xxx-xxxx（宿主机端口 8080）
     ↓
公司前台转接（Docker 端口映射）
     ↓
员工分机：6001（容器端口 80）
```

```bash
docker run -p 8080:80 nginx
# 8080 = 公司对外号码
# 80   = 内部分机号
```

---

### 类比2：数据卷 = 共享网盘/云盘 ☁️

**相似性：** 数据存在云端，本地客户端只是访问入口

```javascript
// 前端：使用云存储
const cloudStorage = require('cloud-sdk');
// 数据存在云端，客户端（浏览器）删了数据还在

// Docker：使用数据卷
// docker run -v /cloud/data:/app/data nginx
// 数据存在宿主机，容器删了数据还在
```

---

### 类比3：端口映射 = Nginx 反向代理 🔄

**相似性：** 都是将请求从一个端口转发到另一个

```nginx
# Nginx 反向代理
server {
    listen 80;
    location / {
        proxy_pass http://backend:3000;
    }
}
```

```bash
# Docker 端口映射
docker run -p 80:3000 my-app
# 效果类似，但更简单
```

---

### 类比4：数据卷 = npm link / 符号链接 🔗

**相似性：** 都是让两个位置指向同一份数据

```bash
# npm link 让两个项目共享一个包
cd my-library
npm link
cd ../my-app
npm link my-library
# my-app/node_modules/my-library → ../my-library

# Docker 数据卷
docker run -v /host/data:/container/data nginx
# 容器内的 /container/data → 宿主机的 /host/data
```

---

### 类比5：端口映射 = 路由器端口转发 🌐

**相似性：** 都是将外部请求转发到内部设备

```
外网请求 → 路由器(公网IP:8080) → 内网设备(192.168.1.100:80)

外部请求 → 宿主机(localhost:8080) → 容器(容器IP:80)
```

```bash
# 路由器设置：外部8080 → 内部192.168.1.100:80
# Docker设置：
docker run -p 8080:80 nginx
```

---

### 类比总结表

| 前端/网络概念 | Docker 概念 | 共同点 |
|---------------|-------------|--------|
| 前台转接电话 | 端口映射 | 外部号码→内部分机 |
| 云盘/网盘 | 数据卷 | 数据持久化存储 |
| Nginx 反向代理 | -p 参数 | 端口转发 |
| npm link | -v 参数 | 路径映射/共享 |
| 路由器端口转发 | 端口映射 | NAT 地址转换 |

---

## 6. 【反直觉点】

### 误区1：-p 80:80 顺序无所谓 ❌

**为什么错？**
- 顺序非常重要：`-p 宿主机:容器`
- 写反了会导致端口映射错误

**为什么人们容易这样错？**
两个端口号看起来一样时容易忽略顺序，或者与其他格式混淆。

**正确理解：**
```bash
# 正确：宿主机 8080 → 容器 80
docker run -p 8080:80 nginx
curl http://localhost:8080  # ✅ 能访问

# 错误理解：以为是 容器:宿主机
docker run -p 80:8080 nginx
curl http://localhost:80    # ✅ 但访问的是容器 8080 端口
curl http://localhost:8080  # ❌ 无法访问

# 记忆技巧：
# 1. 外:内（外面的端口:里面的端口）
# 2. 类比："我用8080访问它的80"
```

---

### 误区2：数据卷目录必须提前创建 ❌

**为什么错？**
- 绑定挂载：宿主机目录不存在时，Docker 会自动创建
- 命名卷：Docker 自动管理，无需手动创建

**为什么人们容易这样错？**
来自传统运维经验，觉得目录必须先存在才能使用。

**正确理解：**
```bash
# Docker 会自动创建目录
docker run -v /not/exist/dir:/app/data nginx
ls /not/exist/dir  # 目录已自动创建

# 但要注意权限问题
# 自动创建的目录属于 root 用户
ls -la /not/exist/
# drwxr-xr-x root root dir

# 最佳实践：提前创建并设置正确权限
mkdir -p ./my_data
docker run -v $(pwd)/my_data:/app/data nginx
```

---

### 误区3：容器停止后数据卷数据也没了 ❌

**为什么错？**
- 数据卷的核心价值就是**持久化**
- 容器停止、删除，数据卷数据都在
- 只有显式删除数据卷（`docker volume rm`）才会丢失数据

**为什么人们容易这样错？**
混淆了"容器内数据"和"数据卷数据"。

**正确理解：**
```bash
# 场景演示
# 1. 创建容器并写入数据
docker run -d --name test-vol -v mydata:/data alpine sh -c "echo 'hello' > /data/test.txt && sleep 3600"

# 2. 查看数据
docker exec test-vol cat /data/test.txt
# 输出: hello

# 3. 删除容器
docker rm -f test-vol

# 4. 数据卷还在！
docker volume ls | grep mydata
# mydata

# 5. 新容器可以访问相同数据
docker run --rm -v mydata:/data alpine cat /data/test.txt
# 输出: hello

# 6. 只有这样才会删除数据
docker volume rm mydata
```

**数据生命周期对比：**
| 操作 | 容器内数据 | 数据卷数据 |
|------|-----------|-----------|
| 停止容器 | 保留 | 保留 |
| 删除容器 | **丢失** | 保留 |
| 删除数据卷 | - | **丢失** |

---

## 7. 【实战代码】

```bash
#!/bin/bash
# 端口映射与数据卷实战演示
# 场景：部署持久化的 Qdrant 向量数据库

echo "===== 端口映射与数据卷实战 ====="

# ===== 1. 创建数据目录 =====
echo ""
echo "=== 1. 创建数据目录 ==="
mkdir -p ./qdrant_demo/storage
mkdir -p ./qdrant_demo/snapshots
echo "目录结构："
ls -la ./qdrant_demo/

# ===== 2. 启动带数据卷的容器 =====
echo ""
echo "=== 2. 启动 Qdrant（带端口映射和数据卷）==="
docker run -d \
  --name qdrant-vol-demo \
  -p 6333:6333 \
  -p 6334:6334 \
  -v $(pwd)/qdrant_demo/storage:/qdrant/storage \
  -v $(pwd)/qdrant_demo/snapshots:/qdrant/snapshots \
  qdrant/qdrant

echo "容器启动完成"
sleep 3

# ===== 3. 验证端口映射 =====
echo ""
echo "=== 3. 验证端口映射 ==="
echo "检查端口监听："
docker port qdrant-vol-demo

echo ""
echo "测试 REST API (6333)："
curl -s http://localhost:6333/collections | head -c 100
echo ""

# ===== 4. 创建测试数据 =====
echo ""
echo "=== 4. 创建向量集合 ==="
curl -s -X PUT 'http://localhost:6333/collections/test_collection' \
  -H 'Content-Type: application/json' \
  --data-raw '{
    "vectors": {
      "size": 4,
      "distance": "Cosine"
    }
  }' | python3 -m json.tool 2>/dev/null || echo "集合创建成功"

# ===== 5. 插入向量数据 =====
echo ""
echo "=== 5. 插入向量数据 ==="
curl -s -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \
  -H 'Content-Type: application/json' \
  --data-raw '{
    "points": [
      {"id": 1, "vector": [0.1, 0.2, 0.3, 0.4], "payload": {"name": "doc1"}},
      {"id": 2, "vector": [0.2, 0.3, 0.4, 0.5], "payload": {"name": "doc2"}},
      {"id": 3, "vector": [0.3, 0.4, 0.5, 0.6], "payload": {"name": "doc3"}}
    ]
  }' | python3 -m json.tool 2>/dev/null || echo "数据插入成功"

# ===== 6. 验证数据写入本地 =====
echo ""
echo "=== 6. 验证数据卷 ==="
echo "宿主机数据目录内容："
ls -la ./qdrant_demo/storage/
echo ""
echo "数据大小："
du -sh ./qdrant_demo/storage/

# ===== 7. 模拟容器重启 =====
echo ""
echo "=== 7. 模拟容器重启（数据应该保留）==="
echo "停止容器..."
docker stop qdrant-vol-demo

echo "删除容器..."
docker rm qdrant-vol-demo

echo "重新启动新容器（使用相同数据卷）..."
docker run -d \
  --name qdrant-vol-demo-new \
  -p 6333:6333 \
  -v $(pwd)/qdrant_demo/storage:/qdrant/storage \
  qdrant/qdrant

sleep 3

# ===== 8. 验证数据持久化 =====
echo ""
echo "=== 8. 验证数据持久化 ==="
echo "查询集合列表："
curl -s http://localhost:6333/collections | python3 -m json.tool 2>/dev/null

echo ""
echo "查询向量数量："
curl -s http://localhost:6333/collections/test_collection | python3 -c "
import sys, json
data = json.load(sys.stdin)
print(f\"集合名: test_collection\")
print(f\"向量数: {data.get('result', {}).get('points_count', 'N/A')}\")
" 2>/dev/null || echo "数据查询成功"

# ===== 9. 端口冲突演示 =====
echo ""
echo "=== 9. 端口冲突处理 ==="
echo "尝试在相同端口启动第二个容器..."
docker run -d --name qdrant-conflict -p 6333:6333 qdrant/qdrant 2>&1 || echo "预期失败：端口已被占用"

echo ""
echo "使用不同端口启动第二个实例："
docker run -d --name qdrant-second -p 6335:6333 qdrant/qdrant
echo "第二个实例可通过 localhost:6335 访问"

# ===== 10. 清理环境 =====
echo ""
echo "=== 10. 清理环境 ==="
docker stop qdrant-vol-demo-new qdrant-second 2>/dev/null
docker rm qdrant-vol-demo-new qdrant-second 2>/dev/null

echo "是否保留数据目录？(数据目录: ./qdrant_demo)"
echo "如需删除请执行: rm -rf ./qdrant_demo"

echo ""
echo "===== 实战演示完成 ====="
```

**运行输出示例：**
```
===== 端口映射与数据卷实战 =====

=== 1. 创建数据目录 ===
目录结构：
drwxr-xr-x  storage
drwxr-xr-x  snapshots

=== 2. 启动 Qdrant（带端口映射和数据卷）===
容器启动完成

=== 3. 验证端口映射 ===
检查端口监听：
6333/tcp -> 0.0.0.0:6333
6334/tcp -> 0.0.0.0:6334

测试 REST API (6333)：
{"result":{"collections":[]},"status":"ok","time":0.00001}

=== 7. 模拟容器重启（数据应该保留）===
停止容器...
删除容器...
重新启动新容器（使用相同数据卷）...

=== 8. 验证数据持久化 ===
查询集合列表：
{
    "result": {
        "collections": [
            {"name": "test_collection"}
        ]
    }
}

集合名: test_collection
向量数: 3

===== 实战演示完成 =====
```

---

## 8. 【面试必问】

### 问题："解释 Docker 的端口映射和数据卷，以及在生产环境中的最佳实践？"

**普通回答（❌ 不出彩）：**
"-p 参数做端口映射，-v 参数挂载数据卷，这样可以访问容器服务和保存数据。"

**出彩回答（✅ 推荐）：**

> **端口映射和数据卷解决了容器化的两个核心问题：**
>
> **1. 端口映射（-p）解决网络隔离问题**
> - 容器默认有独立的网络命名空间，外部无法直接访问
> - `-p 8080:80` 将宿主机 8080 端口的流量转发到容器 80 端口
> - 格式记忆：`外:内`，宿主机端口在前
>
> **2. 数据卷（-v）解决数据持久化问题**
> - 容器的文件系统是临时的，删除容器数据就没了
> - 数据卷将宿主机目录映射到容器内，数据存在宿主机上
> - 两种方式：绑定挂载（开发用）、命名卷（生产用）
>
> **生产环境最佳实践：**
> ```bash
> docker run -d \
>   --name qdrant \
>   -p 6333:6333 \
>   -v qdrant-data:/qdrant/storage \
>   --restart unless-stopped \
>   qdrant/qdrant:v1.6.0
> ```
> - 使用命名卷而非绑定挂载，便于 Docker 管理
> - 指定镜像版本标签，避免自动更新
> - 配置重启策略，保证服务可用性
>
> **在向量数据库部署中**：数据卷尤其重要，因为向量索引的构建非常耗时，必须持久化保存，否则每次重启都要重新建索引。

**为什么这个回答出彩？**
1. ✅ 解释了为什么需要这两个功能（解决什么问题）
2. ✅ 给出了记忆技巧（外:内）
3. ✅ 区分了开发和生产的不同用法
4. ✅ 结合具体场景说明最佳实践

---

## 9. 【化骨绵掌】

### 卡片1：为什么需要端口映射 🚪

**一句话：** 容器网络隔离，端口映射是"开门"让外部访问。

**举例：**
```bash
docker run nginx        # 外部无法访问
docker run -p 80:80 nginx  # 外部可以访问
```

**应用：** 让应用程序能连接容器内的向量数据库。

---

### 卡片2：端口映射语法 🔢

**一句话：** -p 外部端口:内部端口，记住"外:内"。

**举例：**
```bash
docker run -p 8080:80 nginx
# localhost:8080 → 容器:80
```

**应用：** Qdrant 用 `-p 6333:6333` 暴露 REST API。

---

### 卡片3：为什么需要数据卷 💾

**一句话：** 容器删除数据就没，数据卷让数据活得比容器长。

**举例：**
```bash
# 没有数据卷
docker rm my-db  # 数据丢失

# 有数据卷
docker rm my-db  # 数据保留在宿主机
```

**应用：** 向量索引必须持久化，否则每次都要重建。

---

### 卡片4：数据卷语法 📁

**一句话：** -v 宿主机路径:容器路径，记住"主:客"。

**举例：**
```bash
docker run -v /my/data:/app/data nginx
# 宿主机 /my/data ↔ 容器 /app/data
```

**应用：** Qdrant 用 `-v ./data:/qdrant/storage`。

---

### 卡片5：绑定挂载 vs 命名卷 ⚖️

**一句话：** 绑定挂载指定路径，命名卷 Docker 管理。

**举例：**
```bash
# 绑定挂载（开发用）
-v /home/user/data:/data

# 命名卷（生产用）
-v mydata:/data
```

**应用：** 生产环境推荐命名卷，便于备份迁移。

---

### 卡片6：多端口映射 🔌

**一句话：** 可以映射多个端口，每个服务一个 -p。

**举例：**
```bash
docker run \
  -p 6333:6333 \
  -p 6334:6334 \
  qdrant/qdrant
# REST API + gRPC
```

**应用：** 向量数据库通常有 HTTP 和 gRPC 两个端口。

---

### 卡片7：只读挂载 🔒

**一句话：** :ro 让容器只能读不能写，保护配置文件。

**举例：**
```bash
docker run -v ./config:/app/config:ro nginx
# 容器无法修改配置文件
```

**应用：** 挂载配置文件时用只读模式更安全。

---

### 卡片8：端口冲突处理 ⚠️

**一句话：** 一个宿主机端口只能映射一次。

**举例：**
```bash
docker run -p 6333:6333 qdrant/qdrant  # 成功
docker run -p 6333:6333 qdrant/qdrant  # 失败：端口占用
docker run -p 6334:6333 qdrant/qdrant  # 成功：用不同宿主机端口
```

**应用：** 多实例部署时要用不同的宿主机端口。

---

### 卡片9：查看端口和卷 🔍

**一句话：** docker port 和 docker inspect 查看映射详情。

**举例：**
```bash
docker port my-container
# 6333/tcp -> 0.0.0.0:6333

docker volume ls
docker volume inspect mydata
```

**应用：** 排查网络连接问题时先检查端口映射。

---

### 卡片10：生产部署模板 🚀

**一句话：** 端口映射 + 数据卷 + 重启策略 = 生产就绪。

**举例：**
```bash
docker run -d \
  --name qdrant \
  -p 6333:6333 \
  -v qdrant-data:/qdrant/storage \
  --restart unless-stopped \
  qdrant/qdrant:v1.6.0
```

**应用：** 这是部署向量数据库的标准模板。

---

## 10. 【一句话总结】

**端口映射（-p 外:内）打通容器网络隔离让服务可访问，数据卷（-v 主:客）打通文件系统隔离让数据持久化，两者是向量数据库容器化部署的必备配置，确保服务可用且数据安全。**

---

## 📚 学习检查清单

- [ ] 理解为什么需要端口映射和数据卷
- [ ] 记住端口映射语法：-p 外:内
- [ ] 记住数据卷语法：-v 主:客
- [ ] 知道绑定挂载和命名卷的区别
- [ ] 能写出向量数据库的完整部署命令

## 🔗 下一步学习

- [04_docker-compose基础用法.md](./04_docker-compose基础用法.md) - 用配置文件管理多容器

## 📖 配置速查表

| 参数 | 格式 | 示例 | 说明 |
|------|------|------|------|
| -p | 外:内 | -p 8080:80 | 端口映射 |
| -v | 主:客 | -v ./data:/app | 绑定挂载 |
| -v | 卷名:客 | -v mydata:/app | 命名卷 |
| :ro | 路径:ro | -v ./cfg:/cfg:ro | 只读挂载 |

---

**版本：** v1.0  
**最后更新：** 2025-12-05
