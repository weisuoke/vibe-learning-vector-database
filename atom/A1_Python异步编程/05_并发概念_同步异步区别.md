# 并发概念 - 同步/异步区别

## 1. 【30字核心】

**同步是"等结果再继续"，异步是"先做别的等通知"，异步让程序在等待I/O时不闲着，大幅提升效率。**

---

## 2. 【第一性原理】

### 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

### 同步/异步的第一性原理 🎯

#### 1. 最基础的定义

**同步 (Synchronous) = 调用后等待，拿到结果再往下走**
**异步 (Asynchronous) = 调用后不等，结果好了会通知我**

仅此而已！没有更基础的了。

```python
# 同步：打电话点餐，等对方说完才挂
result = sync_call()  # 卡在这里，直到返回
print(result)

# 异步：发微信点餐，发完就去做别的
async_call(callback)  # 立即返回，结果好了调 callback
do_other_things()
```

#### 2. 为什么需要区分同步/异步？

**核心问题：CPU 太快，I/O 太慢，同步等待是巨大的浪费。**

想象一个场景：
- CPU 执行一条指令：0.3 纳秒
- 从内存读数据：100 纳秒（慢 300 倍）
- 从 SSD 读数据：150,000 纳秒（慢 50 万倍）
- 网络请求：150,000,000 纳秒（慢 5 亿倍）

如果用同步方式：
```python
# 向量数据库查询（假设 100ms）
result1 = db.search(query1)  # 等 100ms
result2 = db.search(query2)  # 再等 100ms
result3 = db.search(query3)  # 再等 100ms
# 总共：300ms，CPU 大部分时间在"发呆"
```

如果用异步方式：
```python
# 同时发起三个查询
task1 = async_search(query1)  # 立即返回
task2 = async_search(query2)  # 立即返回
task3 = async_search(query3)  # 立即返回
results = await gather(task1, task2, task3)
# 总共：~100ms（并行等待）
```

#### 3. 同步/异步的三层价值

##### 价值1：资源利用率
异步让 CPU 在等待 I/O 时去做其他事，不"摸鱼"。

```
同步模式：
CPU: [工作][等待........][工作][等待........]
     |    |              |    |
     10ms  90ms          10ms  90ms
     效率：20/200 = 10%

异步模式：
CPU: [工作1][工作2][工作3][处理结果1][处理结果2][处理结果3]
     |      |      |      |          |          |
     同时等待 I/O...
     效率：接近 100%
```

##### 价值2：响应能力
异步让程序在等待时还能响应其他请求。

```python
# 同步 Web 服务器：一次只能处理一个请求
def handle_request(request):
    data = slow_db_query()  # 卡住，其他请求等着
    return response(data)

# 异步 Web 服务器：等待时处理其他请求
async def handle_request(request):
    data = await slow_db_query()  # 等待时去处理别人
    return response(data)
```

##### 价值3：吞吐量
同样的硬件，异步可以处理更多并发请求。

```
1000 个请求，每个需要 100ms I/O：

同步（单线程）：1000 × 100ms = 100 秒
异步（单线程）：~100ms（并行等待）+ 处理时间
```

#### 4. 从第一性原理推导向量数据库应用

**推理链：**
```
1. 向量数据库操作主要是 I/O（网络、磁盘）
   ↓
2. I/O 等待时间远超 CPU 计算时间
   ↓
3. 同步等待造成大量资源浪费
   ↓
4. 异步可以在等待时处理其他查询
   ↓
5. 应用：批量查询、并发插入、流式处理
```

```python
# 同步方式：串行查询，慢
def sync_batch_search(queries):
    results = []
    for q in queries:
        results.append(db.search(q))  # 一个一个等
    return results
# 10 个查询，每个 50ms → 总共 500ms

# 异步方式：并行查询，快
async def async_batch_search(queries):
    tasks = [db.async_search(q) for q in queries]
    return await asyncio.gather(*tasks)  # 并行等待
# 10 个查询，每个 50ms → 总共 ~50ms
```

#### 5. 一句话总结第一性原理

**同步是"我等你"，异步是"你好了叫我"，异步通过避免无谓等待，让程序在 I/O 密集场景下效率倍增。**

---

## 3. 【3个核心概念】

### 核心概念1：阻塞 vs 非阻塞 🚧

**阻塞：调用后线程挂起，直到操作完成**
**非阻塞：调用后立即返回，不管操作是否完成**

```python
import socket

# 阻塞模式（默认）
sock = socket.socket()
sock.connect(('example.com', 80))  # 阻塞，直到连接成功
data = sock.recv(1024)  # 阻塞，直到有数据

# 非阻塞模式
sock.setblocking(False)
try:
    sock.connect(('example.com', 80))  # 立即返回
except BlockingIOError:
    pass  # 连接进行中，稍后检查
```

**同步/异步 vs 阻塞/非阻塞：**

| | 阻塞 | 非阻塞 |
|---|-----|-------|
| **同步** | 调用等待，线程挂起 | 调用等待，但轮询检查 |
| **异步** | （不常见） | 调用返回，完成后通知 |

**最常见的组合：**
- 同步阻塞：传统 I/O（最简单，效率最低）
- 异步非阻塞：现代异步编程（最复杂，效率最高）

---

### 核心概念2：回调 vs async/await 📞

**回调 (Callback)：早期异步方案，把"完成后做什么"作为参数传入**
**async/await：现代异步方案，让异步代码看起来像同步**

```python
# 回调风格（回调地狱）
def step1(callback):
    fetch_data(lambda data:
        process_data(data, lambda result:
            save_result(result, lambda:
                callback("done")
            )
        )
    )

# async/await 风格（清晰）
async def steps():
    data = await fetch_data()
    result = await process_data(data)
    await save_result(result)
    return "done"
```

**回调的问题：**
1. 嵌套深，难读（回调地狱）
2. 错误处理复杂
3. 难以组合多个异步操作

**async/await 的优势：**
1. 代码结构清晰，像同步代码
2. 可以用 try/except 处理错误
3. 易于组合（await 多个任务）

---

### 核心概念3：事件循环 (Event Loop) 🔄

**事件循环是异步编程的核心引擎，负责调度和执行异步任务。**

```python
import asyncio

async def task1():
    print("Task 1 开始")
    await asyncio.sleep(1)  # 让出控制权
    print("Task 1 结束")

async def task2():
    print("Task 2 开始")
    await asyncio.sleep(0.5)
    print("Task 2 结束")

async def main():
    await asyncio.gather(task1(), task2())

asyncio.run(main())
# 输出：
# Task 1 开始
# Task 2 开始
# Task 2 结束（0.5秒后）
# Task 1 结束（1秒后）
```

**事件循环工作原理：**

```
1. 事件循环运行
   ↓
2. 执行 task1，遇到 await sleep(1)
   ↓
3. task1 让出控制权，事件循环记录"1秒后唤醒"
   ↓
4. 执行 task2，遇到 await sleep(0.5)
   ↓
5. task2 让出控制权，事件循环记录"0.5秒后唤醒"
   ↓
6. 没有可运行的任务，事件循环等待
   ↓
7. 0.5秒到，唤醒 task2，执行完毕
   ↓
8. 1秒到，唤醒 task1，执行完毕
```

**在向量数据库中的应用：**
事件循环让我们可以同时发起多个查询，在等待网络响应时处理其他任务。

---

## 4. 【最小可用】

掌握以下内容，就能理解80%的同步/异步场景：

### 4.1 识别同步代码

```python
# 同步代码特征：一行一行顺序执行，遇到 I/O 就等
import requests
import time

def sync_fetch():
    start = time.time()
    
    # 每个请求都要等待完成
    r1 = requests.get('https://api.example.com/1')  # 等...
    r2 = requests.get('https://api.example.com/2')  # 等...
    r3 = requests.get('https://api.example.com/3')  # 等...
    
    print(f"耗时: {time.time() - start:.2f}s")  # ~3秒
```

### 4.2 识别异步代码

```python
# 异步代码特征：async def, await, asyncio
import asyncio
import aiohttp
import time

async def async_fetch():
    start = time.time()
    
    async with aiohttp.ClientSession() as session:
        # 同时发起所有请求
        tasks = [
            session.get('https://api.example.com/1'),
            session.get('https://api.example.com/2'),
            session.get('https://api.example.com/3'),
        ]
        responses = await asyncio.gather(*tasks)  # 并行等待
    
    print(f"耗时: {time.time() - start:.2f}s")  # ~1秒

asyncio.run(async_fetch())
```

### 4.3 理解 await 的作用

```python
async def demo():
    print("1. 开始")
    
    # await = "等这个完成，但等待时让出 CPU 给其他任务"
    await asyncio.sleep(1)
    
    print("2. 1秒后")
    
    result = await fetch_data()  # 等待网络请求
    
    print("3. 数据到了")
    return result
```

### 4.4 并发执行多个任务

```python
import asyncio

async def task(name, delay):
    print(f"{name} 开始")
    await asyncio.sleep(delay)
    print(f"{name} 完成")
    return f"{name} 的结果"

async def main():
    # 方式1：gather - 等所有完成
    results = await asyncio.gather(
        task("A", 1),
        task("B", 2),
        task("C", 1.5)
    )
    print(results)  # ['A 的结果', 'B 的结果', 'C 的结果']

asyncio.run(main())
```

### 4.5 向量数据库并发查询示例

```python
import asyncio

async def search_vector(db, query, name):
    """模拟异步向量搜索"""
    print(f"[{name}] 开始搜索")
    await asyncio.sleep(0.1)  # 模拟网络延迟
    print(f"[{name}] 搜索完成")
    return {'query': name, 'results': [1, 2, 3]}

async def batch_search(db, queries):
    """批量并发搜索"""
    tasks = [
        search_vector(db, q, f"Query_{i}") 
        for i, q in enumerate(queries)
    ]
    return await asyncio.gather(*tasks)

# 运行
async def main():
    queries = [[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]]
    results = await batch_search(None, queries)
    print(f"共 {len(results)} 个结果")

asyncio.run(main())
```

**这些知识足以：**
- 区分同步和异步代码
- 理解 await 的含义
- 编写简单的并发程序
- 为向量数据库批量操作打下基础

---

## 5. 【1个类比】

### 类比1：同步 = fetch().then() 链，异步 = Promise.all() 🎨

```javascript
// JavaScript 同步风格（串行）
fetch('/api/1')
    .then(r1 => fetch('/api/2'))
    .then(r2 => fetch('/api/3'))
    .then(r3 => console.log('全部完成'));
// 总时间 = t1 + t2 + t3

// JavaScript 异步风格（并行）
Promise.all([
    fetch('/api/1'),
    fetch('/api/2'),
    fetch('/api/3')
]).then(results => console.log('全部完成'));
// 总时间 = max(t1, t2, t3)
```

```python
# Python 同步风格
r1 = requests.get('/api/1')
r2 = requests.get('/api/2')
r3 = requests.get('/api/3')

# Python 异步风格
results = await asyncio.gather(
    fetch('/api/1'),
    fetch('/api/2'),
    fetch('/api/3')
)
```

---

### 类比2：同步 = 排队买咖啡，异步 = 取号等叫 ☕

```
同步（排队）：
你 -> [等待] -> [等待] -> [等待] -> 拿到咖啡
     10人在前面，每人2分钟 = 等20分钟

异步（取号）：
你 -> 取号 -> 去旁边刷手机 -> 叫号 -> 拿咖啡
     取号1秒，等待时可以做其他事
```

```python
# 同步：排队等待
def sync_coffee_shop():
    wait_in_line()      # 阻塞等待
    order = place_order()
    wait_for_coffee()   # 阻塞等待
    return coffee

# 异步：取号等叫
async def async_coffee_shop():
    ticket = take_number()       # 立即返回
    order = await place_order()  # 点单后继续
    await browse_phone()         # 等待时做别的
    coffee = await wait_for_call(ticket)
    return coffee
```

---

### 类比3：同步 = XMLHttpRequest，异步 = fetch + async/await 🌐

```javascript
// 古老的同步方式（已弃用，会冻结页面）
var xhr = new XMLHttpRequest();
xhr.open('GET', '/api', false);  // false = 同步
xhr.send();  // 页面卡住直到响应
console.log(xhr.responseText);

// 现代异步方式
async function getData() {
    const response = await fetch('/api');  // 不卡页面
    const data = await response.json();
    console.log(data);
}
```

```python
# Python 同步
response = requests.get('/api')  # 卡住
data = response.json()

# Python 异步
async with aiohttp.ClientSession() as session:
    response = await session.get('/api')  # 不卡
    data = await response.json()
```

---

### 类比4：同步 = 单线程 for 循环，异步 = Promise.all + map 🔁

```javascript
// 同步：串行处理
const results = [];
for (const url of urls) {
    const res = await fetch(url);  // 一个一个等
    results.push(await res.json());
}

// 异步：并行处理
const results = await Promise.all(
    urls.map(url => fetch(url).then(r => r.json()))
);
```

```python
# 同步：串行
results = []
for url in urls:
    response = requests.get(url)
    results.append(response.json())

# 异步：并行
async def fetch_all(urls):
    async with aiohttp.ClientSession() as session:
        tasks = [session.get(url) for url in urls]
        responses = await asyncio.gather(*tasks)
        return [await r.json() for r in responses]
```

---

### 类比5：同步 = React 的 useEffect 无依赖，异步 = React Query 🔄

```javascript
// 同步思维：组件加载时阻塞获取数据（不推荐）
function Component() {
    const [data, setData] = useState(null);
    
    useEffect(() => {
        // 这里虽然是异步，但思维是"等数据来了再渲染"
        fetch('/api').then(r => r.json()).then(setData);
    }, []);
    
    if (!data) return <Loading />;  // 等待中
    return <Display data={data} />;
}

// 异步思维：React Query 自动处理加载状态
function Component() {
    const { data, isLoading } = useQuery('data', fetchData);
    // 组件可以立即渲染，数据异步加载
}
```

---

### 类比总结表

| 同步概念 | 异步概念 | 前端对应 |
|---------|---------|---------|
| 阻塞等待 | 非阻塞 | sync XHR vs fetch |
| 串行执行 | 并行执行 | for-await vs Promise.all |
| 直接返回结果 | 返回 Promise/Future | return vs async |
| 等待完成 | 回调/await | .then() vs await |
| 单任务 | 多任务并发 | 单请求 vs 批量请求 |

---

## 6. 【反直觉点】

### 误区1：异步一定比同步快 ❌

**为什么错？**
- 异步有调度开销
- CPU 密集型任务，异步反而更慢
- 异步的优势在于 I/O 等待场景

**为什么人们容易这样错？**
因为异步教程都在强调"并发"和"高效"，让人误以为任何场景都适用。

**正确理解：**
```python
import asyncio
import time

# CPU 密集型：异步没优势，反而有开销
def cpu_bound_sync():
    return sum(i * i for i in range(10_000_000))

async def cpu_bound_async():
    return sum(i * i for i in range(10_000_000))

# 同步版本可能更快，因为没有协程开销

# I/O 密集型：异步优势明显
async def io_bound_async():
    await asyncio.gather(
        asyncio.sleep(1),
        asyncio.sleep(1),
        asyncio.sleep(1)
    )
    # 总共 ~1 秒

def io_bound_sync():
    time.sleep(1)
    time.sleep(1)
    time.sleep(1)
    # 总共 3 秒
```

**适用场景：**
- ✅ 异步适合：网络请求、文件 I/O、数据库查询
- ❌ 异步不适合：数学计算、图像处理、数据压缩

---

### 误区2：async 函数自动并行执行 ❌

**为什么错？**
- 只有 `await` 时才会让出控制权
- 没有 `await` 的代码依然串行
- 需要用 `gather` 或 `create_task` 才能并行

**为什么人们容易这样错？**
因为看到 `async` 就以为自动变成并行了。

**正确理解：**
```python
import asyncio

async def task(n):
    print(f"Task {n} 开始")
    await asyncio.sleep(1)
    print(f"Task {n} 结束")

# 错误理解：以为自动并行
async def wrong():
    await task(1)  # 等 1 完成
    await task(2)  # 再等 2 完成
    await task(3)  # 再等 3 完成
    # 总共 3 秒！还是串行的

# 正确做法：显式并行
async def right():
    await asyncio.gather(
        task(1),
        task(2),
        task(3)
    )
    # 总共 ~1 秒，真正并行

asyncio.run(wrong())  # 3秒
asyncio.run(right())  # 1秒
```

---

### 误区3：异步 = 多线程 ❌

**为什么错？**
- Python 异步（asyncio）默认是单线程的
- 通过协程切换实现"并发"，不是真正的并行
- 适合 I/O 密集，不适合 CPU 密集

**为什么人们容易这样错？**
因为"并发"和"并行"经常被混用，而且其他语言的异步可能是多线程的。

**正确理解：**
```python
import asyncio
import threading

async def show_thread():
    print(f"线程: {threading.current_thread().name}")
    await asyncio.sleep(0.1)
    print(f"还是同一个线程: {threading.current_thread().name}")

async def main():
    # 所有协程都在同一个线程里！
    await asyncio.gather(
        show_thread(),
        show_thread(),
        show_thread()
    )

asyncio.run(main())
# 输出：
# 线程: MainThread
# 线程: MainThread
# 线程: MainThread
# 还是同一个线程: MainThread
# ...
```

**对比：**

| 特性 | 异步 (asyncio) | 多线程 (threading) |
|-----|---------------|-------------------|
| 线程数 | 1 | 多个 |
| 切换方式 | 协作式（await） | 抢占式（OS 调度） |
| 适合场景 | I/O 密集 | I/O 密集 |
| GIL 影响 | 无 | 有（CPU 密集时） |
| 复杂度 | 低 | 高（竞态条件） |

---

## 7. 【实战代码】

```python
"""
同步/异步对比实战示例
展示两种模式在向量数据库场景中的差异
"""

import asyncio
import time
import random

# ===== 1. 基础对比：同步 vs 异步 =====
print("=== 1. 基础对比 ===")

def sync_task(name, duration):
    """同步任务"""
    print(f"[同步] {name} 开始")
    time.sleep(duration)
    print(f"[同步] {name} 完成")
    return f"{name} 结果"

async def async_task(name, duration):
    """异步任务"""
    print(f"[异步] {name} 开始")
    await asyncio.sleep(duration)
    print(f"[异步] {name} 完成")
    return f"{name} 结果"

# 同步执行
print("\n同步执行 3 个任务：")
start = time.time()
sync_task("A", 0.3)
sync_task("B", 0.3)
sync_task("C", 0.3)
print(f"同步总耗时: {time.time() - start:.2f}s")

# 异步执行
print("\n异步执行 3 个任务：")
async def async_main():
    start = time.time()
    await asyncio.gather(
        async_task("A", 0.3),
        async_task("B", 0.3),
        async_task("C", 0.3)
    )
    print(f"异步总耗时: {time.time() - start:.2f}s")

asyncio.run(async_main())

# ===== 2. 模拟向量数据库查询 =====
print("\n=== 2. 向量数据库查询对比 ===")

def sync_vector_search(query_id, delay=0.1):
    """同步向量搜索（模拟）"""
    time.sleep(delay)  # 模拟网络延迟
    return {
        'query_id': query_id,
        'results': [random.random() for _ in range(3)]
    }

async def async_vector_search(query_id, delay=0.1):
    """异步向量搜索（模拟）"""
    await asyncio.sleep(delay)
    return {
        'query_id': query_id,
        'results': [random.random() for _ in range(3)]
    }

# 同步批量查询
print("\n同步批量查询 10 个向量：")
start = time.time()
sync_results = []
for i in range(10):
    sync_results.append(sync_vector_search(i))
print(f"同步耗时: {time.time() - start:.2f}s")
print(f"获得 {len(sync_results)} 个结果")

# 异步批量查询
print("\n异步批量查询 10 个向量：")
async def async_batch_query():
    start = time.time()
    tasks = [async_vector_search(i) for i in range(10)]
    results = await asyncio.gather(*tasks)
    print(f"异步耗时: {time.time() - start:.2f}s")
    print(f"获得 {len(results)} 个结果")
    return results

asyncio.run(async_batch_query())

# ===== 3. 回调 vs async/await =====
print("\n=== 3. 回调 vs async/await ===")

# 回调风格（难读）
def callback_style():
    def on_data(data):
        def on_processed(result):
            def on_saved(status):
                print(f"回调完成: {status}")
            save_data(result, on_saved)
        process_data(data, on_processed)
    fetch_data(on_data)

# async/await 风格（清晰）
async def async_style():
    data = await async_fetch_data()
    result = await async_process_data(data)
    status = await async_save_data(result)
    print(f"异步完成: {status}")
    return status

# 模拟实现
async def async_fetch_data():
    await asyncio.sleep(0.1)
    return {"data": [1, 2, 3]}

async def async_process_data(data):
    await asyncio.sleep(0.1)
    return {"processed": sum(data["data"])}

async def async_save_data(result):
    await asyncio.sleep(0.1)
    return "saved"

print("async/await 风格执行：")
asyncio.run(async_style())

# ===== 4. 错误处理对比 =====
print("\n=== 4. 错误处理 ===")

async def might_fail(should_fail=False):
    await asyncio.sleep(0.1)
    if should_fail:
        raise ValueError("模拟错误")
    return "成功"

async def error_handling():
    # 单个任务的错误处理
    try:
        result = await might_fail(True)
    except ValueError as e:
        print(f"捕获错误: {e}")
    
    # 多个任务的错误处理
    tasks = [
        might_fail(False),
        might_fail(True),   # 这个会失败
        might_fail(False),
    ]
    
    # return_exceptions=True 让错误作为结果返回，不中断
    results = await asyncio.gather(*tasks, return_exceptions=True)
    for i, r in enumerate(results):
        if isinstance(r, Exception):
            print(f"任务 {i} 失败: {r}")
        else:
            print(f"任务 {i} 成功: {r}")

asyncio.run(error_handling())

# ===== 5. 超时控制 =====
print("\n=== 5. 超时控制 ===")

async def slow_operation():
    await asyncio.sleep(5)  # 模拟慢操作
    return "完成"

async def with_timeout():
    try:
        # 设置 1 秒超时
        result = await asyncio.wait_for(slow_operation(), timeout=1.0)
        print(f"结果: {result}")
    except asyncio.TimeoutError:
        print("操作超时！")

asyncio.run(with_timeout())

# ===== 6. 并发限制 =====
print("\n=== 6. 并发限制（信号量）===")

async def limited_task(sem, task_id):
    async with sem:  # 获取信号量
        print(f"任务 {task_id} 开始（并发中）")
        await asyncio.sleep(0.3)
        print(f"任务 {task_id} 完成")
        return task_id

async def limited_concurrency():
    # 限制最多 3 个并发
    sem = asyncio.Semaphore(3)
    
    tasks = [limited_task(sem, i) for i in range(10)]
    
    start = time.time()
    results = await asyncio.gather(*tasks)
    print(f"耗时: {time.time() - start:.2f}s")
    print(f"结果: {results}")

asyncio.run(limited_concurrency())

# ===== 7. 实际场景：向量数据库批量插入 =====
print("\n=== 7. 向量数据库批量插入 ===")

class MockVectorDB:
    """模拟向量数据库"""
    def __init__(self):
        self.data = []
    
    async def insert(self, vector, delay=0.05):
        await asyncio.sleep(delay)  # 模拟网络
        self.data.append(vector)
        return len(self.data)
    
    async def batch_insert(self, vectors):
        """批量插入"""
        tasks = [self.insert(v) for v in vectors]
        return await asyncio.gather(*tasks)

async def insert_demo():
    db = MockVectorDB()
    
    # 生成 100 个向量
    vectors = [[random.random() for _ in range(4)] for _ in range(100)]
    
    # 异步批量插入
    start = time.time()
    results = await db.batch_insert(vectors)
    print(f"插入 {len(results)} 条，耗时: {time.time() - start:.2f}s")
    
    # 如果是同步，需要 100 * 0.05 = 5 秒
    # 异步只需要约 0.05 秒（并发）

asyncio.run(insert_demo())

# ===== 8. 生产者-消费者模式 =====
print("\n=== 8. 生产者-消费者模式 ===")

async def producer(queue, n):
    """生产者：生成向量"""
    for i in range(n):
        vector = [random.random() for _ in range(4)]
        await queue.put({'id': i, 'vector': vector})
        print(f"生产: vector_{i}")
        await asyncio.sleep(0.1)
    await queue.put(None)  # 结束信号

async def consumer(queue, name):
    """消费者：处理向量"""
    while True:
        item = await queue.get()
        if item is None:
            await queue.put(None)  # 传递结束信号
            break
        print(f"{name} 消费: vector_{item['id']}")
        await asyncio.sleep(0.15)  # 模拟处理

async def producer_consumer():
    queue = asyncio.Queue(maxsize=5)
    
    await asyncio.gather(
        producer(queue, 5),
        consumer(queue, "消费者A"),
        consumer(queue, "消费者B"),
    )

asyncio.run(producer_consumer())
```

**运行输出示例：**
```
=== 1. 基础对比 ===

同步执行 3 个任务：
[同步] A 开始
[同步] A 完成
[同步] B 开始
[同步] B 完成
[同步] C 开始
[同步] C 完成
同步总耗时: 0.90s

异步执行 3 个任务：
[异步] A 开始
[异步] B 开始
[异步] C 开始
[异步] A 完成
[异步] B 完成
[异步] C 完成
异步总耗时: 0.30s

=== 2. 向量数据库查询对比 ===

同步批量查询 10 个向量：
同步耗时: 1.00s
获得 10 个结果

异步批量查询 10 个向量：
异步耗时: 0.10s
获得 10 个结果
...
```

---

## 8. 【面试必问】

### 问题1："什么是同步和异步？有什么区别？"

**普通回答（❌ 不出彩）：**
"同步就是一行一行执行，异步就是可以同时执行多个任务。"

**出彩回答（✅ 推荐）：**

> **同步和异步的核心区别在于"等待方式"：**
>
> 1. **同步**：调用一个操作后，必须等它完成才能继续。就像打电话点餐，必须等对方说完才能挂。
>
> 2. **异步**：调用后立即返回，操作在"后台"进行，完成后通知你。就像发微信点餐，发完可以去做别的。
>
> **为什么异步重要：**
> - CPU 很快，I/O 很慢（网络请求可能是 CPU 指令的 5 亿倍慢）
> - 同步等待 = CPU 在"发呆"
> - 异步让 CPU 在等待时去做其他事
>
> **实际应用（向量数据库）：**
> ```python
> # 同步：10 个查询串行，每个 100ms → 1 秒
> for q in queries:
>     results.append(db.search(q))
>
> # 异步：10 个查询并行 → 100ms
> results = await asyncio.gather(*[db.search(q) for q in queries])
> ```
>
> **选择原则**：I/O 密集用异步，CPU 密集用多进程。

---

### 问题2："Python 的异步是多线程吗？"

**普通回答（❌ 不出彩）：**
"不是，异步是协程。"

**出彩回答（✅ 推荐）：**

> **Python asyncio 默认是单线程的，但能实现"并发"：**
>
> 1. **机制**：通过事件循环 + 协程切换，在一个线程里模拟并发
>
> 2. **与多线程的区别**：
>    | | asyncio | threading |
>    |---|---------|-----------|
>    | 线程数 | 1 | 多个 |
>    | 切换 | 协作式（await） | 抢占式 |
>    | 竞态 | 无（单线程） | 有 |
>
> 3. **为什么能提升效率**：
>    - I/O 等待时，协程让出控制权
>    - 事件循环调度其他协程运行
>    - 所有等待"并行"进行
>
> 4. **局限性**：
>    - CPU 密集型任务没有优势
>    - 一个协程卡住（不 await），其他都卡
>
> **记住**：异步 ≠ 并行，异步是"高效等待"，并行是"同时计算"。

---

## 9. 【化骨绵掌】

### 卡片1：同步是什么？ 🎯

**一句话：** 同步 = 调用后等待，拿到结果再继续。

**类比：** 打电话点餐，必须等对方说完才能挂。

```python
result = slow_function()  # 卡在这里
print(result)  # 等完才执行
```

---

### 卡片2：异步是什么？ 🚀

**一句话：** 异步 = 调用后不等，结果好了会通知。

**类比：** 发微信点餐，发完可以去做别的。

```python
task = async_function()  # 立即返回
do_other_things()
result = await task  # 需要时再等
```

---

### 卡片3：为什么需要异步？ ⏱️

**一句话：** CPU 太快，I/O 太慢，同步等待是浪费。

**数据：**
- CPU 指令：0.3 纳秒
- 网络请求：150,000,000 纳秒
- 差距：5 亿倍！

同步 = CPU 在"发呆"等 I/O

---

### 卡片4：async/await 语法 📝

**一句话：** async 定义异步函数，await 等待异步操作。

```python
async def fetch_data():
    result = await http_request()
    return result

# 调用
data = await fetch_data()
```

---

### 卡片5：并行执行 gather ⚡

**一句话：** asyncio.gather 让多个任务并行执行。

```python
# 串行：3秒
await task1()  # 1秒
await task2()  # 1秒
await task3()  # 1秒

# 并行：1秒
await asyncio.gather(task1(), task2(), task3())
```

---

### 卡片6：事件循环 🔄

**一句话：** 事件循环是异步的"调度中心"。

```python
asyncio.run(main())
# 1. 创建事件循环
# 2. 运行 main 协程
# 3. 遇到 await 就切换
# 4. 所有任务完成后结束
```

---

### 卡片7：异步 ≠ 多线程 ⚠️

**一句话：** Python asyncio 是单线程的协程切换。

**区别：**
| asyncio | threading |
|---------|-----------|
| 单线程 | 多线程 |
| 协作切换 | 抢占切换 |
| 无竞态 | 有竞态 |

---

### 卡片8：适用场景 ✅

**一句话：** I/O 密集用异步，CPU 密集用多进程。

**适合异步：**
- 网络请求
- 数据库查询
- 文件读写

**不适合异步：**
- 数学计算
- 图像处理

---

### 卡片9：错误处理 🛡️

**一句话：** 异步代码用 try/except，和同步一样。

```python
try:
    result = await risky_operation()
except ValueError as e:
    print(f"错误: {e}")

# gather 可以返回异常
results = await asyncio.gather(
    *tasks, return_exceptions=True
)
```

---

### 卡片10：向量数据库应用 🗄️

**一句话：** 异步让批量查询从串行变并行。

```python
# 10 个查询，每个 100ms
# 同步：1000ms
# 异步：~100ms

results = await asyncio.gather(*[
    db.search(q) for q in queries
])
```

---

## 10. 【一句话总结】

**同步是"调用后等待结果"，异步是"调用后继续做别的、结果好了再处理"，异步通过避免 I/O 等待时的 CPU 空闲，在向量数据库批量查询等 I/O 密集场景下可将效率提升数倍甚至数十倍。**

---

## 📚 学习检查清单

- [ ] 能用自己的话解释同步和异步
- [ ] 理解阻塞和非阻塞的区别
- [ ] 知道 async/await 的基本语法
- [ ] 能用 asyncio.gather 并行执行任务
- [ ] 理解事件循环的作用
- [ ] 知道异步适合什么场景
- [ ] 能区分异步和多线程

## 🔗 下一步学习

学完同步/异步区别后，建议学习：
1. **I/O 密集理解** - 深入理解异步的应用场景
2. **async/await** - 详细语法和用法
3. **asyncio.run** - 运行异步程序
