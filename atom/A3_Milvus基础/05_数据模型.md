# 核心概念：数据模型（向量字段 + 标量字段）

---

## 1. 【30字核心】

**Milvus数据模型由向量字段和标量字段组成，向量字段存储Embedding用于相似搜索，标量字段存储元数据用于过滤。**

---

## 2. 【第一性原理】

### 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

### 数据模型的第一性原理 🎯

#### 1. 最基础的定义

**数据模型 = 向量字段 + 标量字段**

- **向量字段**：存储Embedding向量，用于相似性搜索
- **标量字段**：存储元数据（数字、字符串、布尔等），用于过滤和展示

仅此而已！没有更基础的了。

#### 2. 为什么需要混合数据模型？

**核心问题：如何实现"语义搜索 + 精确过滤"？**

想象一下电商搜索场景：
- 用户搜索"舒适的跑鞋"（语义搜索）
- 同时要求：价格100-500元、品牌Nike、有货（精确过滤）

```
纯向量搜索：只能找语义相似的，无法过滤
纯标量查询：只能精确匹配，不懂语义

混合模型：
1. 向量字段存储商品描述的Embedding
2. 标量字段存储价格、品牌、库存等
3. 搜索时：向量相似 + 标量过滤
```

#### 3. 数据模型的三层价值

##### 价值1：语义理解
- 向量字段捕获语义信息
- 支持模糊、概念级别的搜索
- "跑鞋"能匹配"运动鞋"、"慢跑鞋"

##### 价值2：精确过滤
- 标量字段支持精确条件
- 价格范围、类别匹配、时间过滤
- 保证业务逻辑正确性

##### 价值3：数据完整性
- 一个Collection存储完整信息
- 减少跨系统查询
- 简化应用架构

#### 4. 从第一性原理推导数据模型设计

**推理链：**
```
1. 业务需要语义搜索 → 需要向量字段
   ↓
2. 业务需要精确过滤 → 需要标量字段
   ↓
3. 搜索结果需要展示 → 需要存储元数据
   ↓
4. 需要关联外部系统 → 需要主键
   ↓
5. 数据模型 = 主键 + 向量字段 + 标量字段
   ↓
6. 合理设计字段类型和索引
   ↓
7. 实现高效的混合查询
```

#### 5. 一句话总结第一性原理

**数据模型是向量字段和标量字段的组合，向量负责语义搜索，标量负责精确过滤，两者配合实现智能且精准的检索。**

---

## 3. 【3个核心概念】

### 核心概念1：向量字段（Vector Field）🔢

**向量字段存储Embedding向量，是相似性搜索的基础**

```python
from pymilvus import FieldSchema, DataType

# 浮点向量字段（最常用）
embedding_field = FieldSchema(
    name="embedding",
    dtype=DataType.FLOAT_VECTOR,
    dim=768  # 向量维度，必须指定
)

# 二进制向量字段（用于哈希特征）
binary_field = FieldSchema(
    name="hash_vector",
    dtype=DataType.BINARY_VECTOR,
    dim=256  # 必须是8的倍数
)

# 稀疏向量字段（Milvus 2.4+，用于稀疏表示）
sparse_field = FieldSchema(
    name="sparse_embedding",
    dtype=DataType.SPARSE_FLOAT_VECTOR
    # 稀疏向量不需要指定dim
)
```

**向量字段的关键属性：**
| 属性 | 说明 | 示例 |
|-----|------|-----|
| dim | 向量维度 | 768（BERT）、1536（OpenAI）|
| dtype | 数据类型 | FLOAT_VECTOR、BINARY_VECTOR |
| 索引 | 必须创建索引 | IVF_FLAT、HNSW |

**在向量数据库中的应用：**
向量字段存储文本、图像、音频的Embedding，是语义搜索的核心。

---

### 核心概念2：标量字段（Scalar Field）📝

**标量字段存储元数据，用于过滤、排序和展示**

```python
from pymilvus import FieldSchema, DataType

# 数值字段
int_field = FieldSchema(name="price", dtype=DataType.INT64)
float_field = FieldSchema(name="score", dtype=DataType.FLOAT)

# 字符串字段
varchar_field = FieldSchema(
    name="title",
    dtype=DataType.VARCHAR,
    max_length=500  # 必须指定最大长度
)

# 布尔字段
bool_field = FieldSchema(name="is_active", dtype=DataType.BOOL)

# JSON字段（灵活存储）
json_field = FieldSchema(name="metadata", dtype=DataType.JSON)

# 数组字段（Milvus 2.4+）
array_field = FieldSchema(
    name="tags",
    dtype=DataType.ARRAY,
    element_type=DataType.VARCHAR,
    max_capacity=10,
    max_length=100
)
```

**支持的标量类型：**
| 类型 | 说明 | 过滤支持 |
|-----|------|---------|
| INT8/16/32/64 | 整数 | 比较、范围 |
| FLOAT/DOUBLE | 浮点数 | 比较、范围 |
| VARCHAR | 字符串 | 相等、LIKE |
| BOOL | 布尔 | 相等 |
| JSON | JSON对象 | 路径访问 |
| ARRAY | 数组 | 包含查询 |

**在向量数据库中的应用：**
标量字段存储商品价格、文档类别、用户ID等，支持业务过滤条件。

---

### 核心概念3：混合查询（Hybrid Search）🔀

**混合查询同时使用向量相似搜索和标量条件过滤**

```python
from pymilvus import Collection

collection = Collection("products")
collection.load()

# 查询向量
query_embedding = get_embedding("舒适的跑鞋")

# 混合查询：向量搜索 + 标量过滤
results = collection.search(
    data=[query_embedding],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 16}},
    limit=10,
    # 标量过滤条件
    expr='price >= 100 and price <= 500 and brand == "Nike" and stock > 0',
    # 返回的标量字段
    output_fields=["title", "price", "brand", "image_url"]
)

# 结果同时满足：
# 1. 语义上与"舒适的跑鞋"相似
# 2. 价格在100-500之间
# 3. 品牌是Nike
# 4. 有库存
```

**过滤表达式语法：**
```python
# 比较运算
expr = "price > 100"
expr = "score >= 4.5"

# 逻辑运算
expr = "price > 100 and category == 'shoes'"
expr = "brand == 'Nike' or brand == 'Adidas'"
expr = "not is_deleted"

# 范围查询
expr = "price >= 100 and price <= 500"

# 字符串匹配
expr = 'title like "%跑鞋%"'

# IN查询
expr = "category in ['shoes', 'clothing']"

# JSON字段访问
expr = 'metadata["color"] == "red"'

# 数组包含
expr = 'array_contains(tags, "sport")'
```

**在向量数据库中的应用：**
混合查询是生产环境最常用的查询方式，实现"智能搜索 + 精确过滤"。

---

## 4. 【最小可用】

掌握以下内容，就能设计出实用的数据模型：

### 4.1 完整的Schema设计模板

```python
from pymilvus import FieldSchema, CollectionSchema, DataType

# 通用的数据模型模板
def create_schema(vector_dim=768, enable_dynamic=True):
    fields = [
        # 1. 主键（必需）
        FieldSchema(
            name="id",
            dtype=DataType.INT64,
            is_primary=True,
            auto_id=True  # 或False手动指定
        ),
        
        # 2. 向量字段（必需，至少一个）
        FieldSchema(
            name="embedding",
            dtype=DataType.FLOAT_VECTOR,
            dim=vector_dim
        ),
        
        # 3. 常用标量字段
        FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=500),
        FieldSchema(name="content", dtype=DataType.VARCHAR, max_length=5000),
        FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=100),
        FieldSchema(name="created_at", dtype=DataType.INT64),  # 时间戳
        FieldSchema(name="score", dtype=DataType.FLOAT),
        FieldSchema(name="is_active", dtype=DataType.BOOL),
        
        # 4. JSON字段（灵活扩展）
        FieldSchema(name="metadata", dtype=DataType.JSON),
    ]
    
    schema = CollectionSchema(
        fields=fields,
        description="通用文档集合",
        enable_dynamic_field=enable_dynamic  # 允许动态字段
    )
    
    return schema
```

### 4.2 常见场景的数据模型

```python
# 场景1：RAG文档检索
rag_fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="doc_id", dtype=DataType.VARCHAR, max_length=100),  # 文档ID
    FieldSchema(name="chunk_id", dtype=DataType.INT64),                   # 分块序号
    FieldSchema(name="content", dtype=DataType.VARCHAR, max_length=2000), # 文本内容
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768),  # 向量
    FieldSchema(name="source", dtype=DataType.VARCHAR, max_length=200),   # 来源
    FieldSchema(name="page_num", dtype=DataType.INT64),                   # 页码
]

# 场景2：电商商品搜索
product_fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="product_id", dtype=DataType.VARCHAR, max_length=50),
    FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=200),
    FieldSchema(name="description", dtype=DataType.VARCHAR, max_length=1000),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
    FieldSchema(name="price", dtype=DataType.FLOAT),
    FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=50),
    FieldSchema(name="brand", dtype=DataType.VARCHAR, max_length=50),
    FieldSchema(name="stock", dtype=DataType.INT64),
    FieldSchema(name="rating", dtype=DataType.FLOAT),
]

# 场景3：图像搜索
image_fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="image_url", dtype=DataType.VARCHAR, max_length=500),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=512),  # 图像特征
    FieldSchema(name="width", dtype=DataType.INT64),
    FieldSchema(name="height", dtype=DataType.INT64),
    FieldSchema(name="format", dtype=DataType.VARCHAR, max_length=10),
    FieldSchema(name="tags", dtype=DataType.JSON),  # ["cat", "animal", "pet"]
]
```

### 4.3 插入数据

```python
import numpy as np
from pymilvus import Collection

collection = Collection("products")

# 方式1：列表格式（按Schema顺序）
data = [
    ["产品A", "产品B"],                          # title
    ["描述A", "描述B"],                          # description
    np.random.rand(2, 768).tolist(),           # embedding
    [99.0, 199.0],                              # price
    ["电子", "服装"],                            # category
    ["Apple", "Nike"],                          # brand
    [100, 50],                                  # stock
    [4.5, 4.8],                                 # rating
]
collection.insert(data)

# 方式2：字典格式（更清晰）
data = [
    {
        "title": "产品C",
        "description": "描述C",
        "embedding": np.random.rand(768).tolist(),
        "price": 299.0,
        "category": "家居",
        "brand": "IKEA",
        "stock": 200,
        "rating": 4.6
    }
]
collection.insert(data)
```

### 4.4 查询数据

```python
# 向量搜索 + 标量过滤
results = collection.search(
    data=[query_embedding],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 16}},
    limit=10,
    expr='price < 200 and rating >= 4.0',
    output_fields=["title", "price", "rating"]
)

# 纯标量查询
results = collection.query(
    expr='category == "电子" and stock > 0',
    output_fields=["title", "price", "stock"],
    limit=100
)
```

**这些知识足以：**
- 设计符合业务需求的数据模型
- 存储完整的业务数据
- 实现混合查询
- 支持常见的应用场景

---

## 5. 【1个类比】

### 类比：数据模型 = 前端状态管理 🎨

把Milvus数据模型类比为前端开发中的**状态管理和数据结构设计**，会更容易理解：

### 类比1：Schema = TypeScript类型定义 📋

```typescript
// TypeScript类型定义
interface Product {
  id: number;                    // 主键
  title: string;                 // 标量字段
  description: string;           // 标量字段
  embedding: number[];           // 向量字段
  price: number;                 // 标量字段
  category: string;              // 标量字段
  metadata?: Record<string, any>; // 动态字段
}
```

```python
# Milvus Schema定义
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True),
    FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=200),
    FieldSchema(name="description", dtype=DataType.VARCHAR, max_length=1000),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
    FieldSchema(name="price", dtype=DataType.FLOAT),
    FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=50),
]
schema = CollectionSchema(fields, enable_dynamic_field=True)  # 动态字段
```

**相似点：** 都是定义数据结构和类型约束

---

### 类比2：向量字段 = 计算属性/派生状态 🧮

```javascript
// React中的派生状态
const ProductCard = ({ title, description }) => {
  // embedding是从title和description计算出来的
  const embedding = useMemo(() => {
    return computeEmbedding(title + ' ' + description);
  }, [title, description]);
  
  return <div>...</div>;
};

// 或者Redux中的selector
const selectProductEmbedding = (state, productId) => {
  const product = state.products[productId];
  return computeEmbedding(product.title + product.description);
};
```

```python
# Milvus中的向量字段
# embedding是从title和description通过模型计算得到的
embedding = embedding_model.encode(f"{title} {description}")

# 存储时：
collection.insert({
    "title": title,
    "description": description,
    "embedding": embedding,  # 计算得到的向量
    ...
})
```

**相似点：** 向量字段是从原始数据派生计算的

---

### 类比3：混合查询 = 组合筛选条件 🔀

```javascript
// 前端筛选逻辑
const filterProducts = (products, filters) => {
  return products
    // 语义搜索（向量相似）
    .map(p => ({
      ...p,
      similarity: cosineSimilarity(queryEmbedding, p.embedding)
    }))
    .filter(p => p.similarity > 0.8)  // 相似度阈值
    // 标量过滤
    .filter(p => p.price >= filters.minPrice)
    .filter(p => p.price <= filters.maxPrice)
    .filter(p => filters.categories.includes(p.category))
    .filter(p => p.stock > 0)
    // 排序
    .sort((a, b) => b.similarity - a.similarity)
    .slice(0, 10);
};
```

```python
# Milvus混合查询
results = collection.search(
    data=[query_embedding],
    anns_field="embedding",
    param={"metric_type": "COSINE"},
    limit=10,
    expr='price >= 100 and price <= 500 and category in ["shoes"] and stock > 0'
)
```

**相似点：** 都是组合多个条件进行筛选

---

### 类比4：JSON字段 = 动态对象属性 📦

```javascript
// JavaScript动态对象
const product = {
  id: 1,
  title: "跑鞋",
  // metadata可以存储任意属性
  metadata: {
    color: "red",
    size: [38, 39, 40, 41, 42],
    material: "mesh",
    customField: "anything"
  }
};

// 访问动态属性
console.log(product.metadata.color);
console.log(product.metadata.size);
```

```python
# Milvus JSON字段
data = {
    "id": 1,
    "title": "跑鞋",
    "embedding": [...],
    "metadata": {
        "color": "red",
        "size": [38, 39, 40, 41, 42],
        "material": "mesh",
        "customField": "anything"
    }
}

# 查询时访问JSON字段
expr = 'metadata["color"] == "red"'
```

**相似点：** 都支持灵活的动态属性

---

### 类比5：output_fields = GraphQL选择字段 🎯

```graphql
# GraphQL只返回需要的字段
query GetProducts {
  products(filter: { category: "shoes" }) {
    id
    title
    price
    # 不需要返回embedding（太大了）
    # 不需要返回description（不显示）
  }
}
```

```python
# Milvus只返回需要的字段
results = collection.search(
    ...,
    output_fields=["title", "price"]  # 只返回这些字段
    # 不返回embedding（太大）
    # 不返回description（不需要）
)
```

**相似点：** 都是按需选择返回的字段

---

### 类比总结表

| Milvus概念 | 前端类比 | 相似点 |
|-----------|---------|-------|
| Schema | TypeScript接口 | 类型定义 |
| 向量字段 | 计算属性/派生状态 | 由原始数据计算 |
| 标量字段 | 对象属性 | 原始数据存储 |
| 混合查询 | 组合filter | 多条件筛选 |
| JSON字段 | 动态对象 | 灵活扩展 |
| output_fields | GraphQL字段选择 | 按需返回 |

---

## 6. 【反直觉点】

### 误区1：向量字段越多越好 ❌

**为什么错？**
- 每个向量字段都需要单独的索引
- 多向量搜索需要结果融合，复杂度高
- 存储成本成倍增加
- 大多数场景一个向量字段足够

**为什么人们容易这样错？**
觉得不同维度的信息应该用不同向量表示。

**正确理解：**
```python
# ❌ 错误：为每种信息创建向量字段
fields = [
    FieldSchema(name="title_embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
    FieldSchema(name="description_embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
    FieldSchema(name="category_embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
    FieldSchema(name="tags_embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
]
# 4个向量字段，索引和存储成本x4！

# ✅ 正确：合并信息生成一个向量
def generate_embedding(product):
    # 合并所有文本信息
    text = f"{product['title']} {product['description']} " \
           f"{product['category']} {' '.join(product['tags'])}"
    return embedding_model.encode(text)

fields = [
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
]
# 一个向量字段，高效且简单

# 如果确实需要多向量搜索（如图文混合）
# 可以考虑：
# 1. 分成多个Collection
# 2. 使用Milvus的多向量搜索功能（2.4+）
```

---

### 误区2：所有元数据都存在Milvus ❌

**为什么错？**
- Milvus不是通用数据库
- 大文本存储效率低
- 复杂查询能力有限
- 可能影响搜索性能

**为什么人们容易这样错？**
想简化架构，一个数据库存所有数据。

**正确理解：**
```python
# ❌ 错误：Milvus存储完整数据
milvus_data = {
    "id": 1,
    "title": "产品标题",
    "description": "这是一段很长很长的描述...",  # 几千字
    "full_content": "完整的HTML内容...",          # 可能几MB
    "images": ["url1", "url2", ...],             # 大量图片URL
    "reviews": [{"user": ..., "text": ...}],     # 评论数据
    "embedding": [...]
}

# ✅ 正确：Milvus只存储搜索相关的数据
# Milvus存储
milvus_data = {
    "id": 1,                     # 关联业务数据库的ID
    "embedding": [...],          # 向量
    "title": "产品标题",          # 展示用
    "category": "电子",           # 过滤用
    "price": 999.0,              # 过滤用
}

# MySQL/PostgreSQL存储完整数据
mysql_data = {
    "id": 1,
    "title": "产品标题",
    "description": "这是一段很长很长的描述...",
    "full_content": "完整的HTML内容...",
    "images": [...],
    "reviews": [...],
    # ... 其他完整数据
}

# 查询流程
# 1. Milvus搜索，返回ID列表
ids = milvus_search(query_embedding)  # [1, 5, 8]

# 2. 用ID去MySQL查完整数据
full_data = mysql.query("SELECT * FROM products WHERE id IN (1, 5, 8)")
```

---

### 误区3：VARCHAR长度设置很大没关系 ❌

**为什么错？**
- max_length影响内存分配
- 过大的max_length浪费资源
- 可能影响查询性能
- 超长文本应该用其他方式存储

**为什么人们容易这样错？**
觉得设大点"保险"，反正不影响实际存储。

**正确理解：**
```python
# ❌ 错误：max_length设置过大
fields = [
    FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=10000),
    FieldSchema(name="description", dtype=DataType.VARCHAR, max_length=65535),
]
# 即使实际数据很短，也会预留大量空间

# ✅ 正确：根据实际需求设置
fields = [
    FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=200),
    FieldSchema(name="description", dtype=DataType.VARCHAR, max_length=1000),
]

# 评估方法：
# 1. 统计实际数据的长度分布
# 2. 取99%分位数作为max_length
# 3. 超长的特殊处理（截断或存别处）

import pandas as pd

# 假设有原始数据
df = pd.read_csv("products.csv")

# 统计title长度
title_lengths = df['title'].str.len()
print(f"Title长度分布:")
print(f"  平均: {title_lengths.mean():.0f}")
print(f"  最大: {title_lengths.max()}")
print(f"  99%分位: {title_lengths.quantile(0.99):.0f}")
# 输出：Title长度分布: 平均: 45, 最大: 312, 99%分位: 120
# → max_length设为150比较合理
```

---

## 7. 【实战代码】

```python
"""
数据模型设计实战：RAG系统的完整数据模型

运行前提：
1. pip install pymilvus numpy
2. Docker启动Milvus
"""

import numpy as np
import json
import time
from pymilvus import (
    connections,
    Collection,
    FieldSchema,
    CollectionSchema,
    DataType,
    utility
)

# ===== 1. 连接Milvus =====
print("=== 1. 连接Milvus ===")
connections.connect(host="localhost", port="19530")
print("✓ 连接成功")

# ===== 2. 设计RAG文档数据模型 =====
print("\n=== 2. 设计RAG文档数据模型 ===")

collection_name = "rag_documents"

if utility.has_collection(collection_name):
    utility.drop_collection(collection_name)

# RAG系统的数据模型
fields = [
    # 主键
    FieldSchema(
        name="id",
        dtype=DataType.INT64,
        is_primary=True,
        auto_id=True
    ),
    
    # 向量字段 - 用于语义搜索
    FieldSchema(
        name="embedding",
        dtype=DataType.FLOAT_VECTOR,
        dim=768
    ),
    
    # 文档标识
    FieldSchema(name="doc_id", dtype=DataType.VARCHAR, max_length=100),
    FieldSchema(name="chunk_id", dtype=DataType.INT64),
    
    # 文本内容
    FieldSchema(name="content", dtype=DataType.VARCHAR, max_length=2000),
    FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=200),
    
    # 过滤字段
    FieldSchema(name="source", dtype=DataType.VARCHAR, max_length=100),
    FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=50),
    FieldSchema(name="created_at", dtype=DataType.INT64),
    FieldSchema(name="is_active", dtype=DataType.BOOL),
    
    # 元数据（灵活扩展）
    FieldSchema(name="metadata", dtype=DataType.JSON),
]

schema = CollectionSchema(
    fields=fields,
    description="RAG文档检索系统",
    enable_dynamic_field=True
)

collection = Collection(name=collection_name, schema=schema)
print(f"✓ 创建Collection: {collection_name}")

# 打印Schema信息
print("\nSchema字段:")
for field in schema.fields:
    field_info = f"  {field.name}: {field.dtype}"
    if field.dtype == DataType.FLOAT_VECTOR:
        field_info += f" (dim={field.params.get('dim')})"
    elif field.dtype == DataType.VARCHAR:
        field_info += f" (max_length={field.params.get('max_length')})"
    print(field_info)

# ===== 3. 准备测试数据 =====
print("\n=== 3. 准备测试数据 ===")

np.random.seed(42)

# 模拟文档数据
documents = [
    {
        "doc_id": "doc_001",
        "title": "Python入门教程",
        "chunks": [
            "Python是一门简单易学的编程语言。它具有清晰的语法和强大的标准库。",
            "Python支持多种编程范式，包括面向对象、函数式和过程式编程。",
            "安装Python非常简单，访问官网下载安装包，按照向导即可完成安装。"
        ],
        "source": "技术文档",
        "category": "编程语言"
    },
    {
        "doc_id": "doc_002",
        "title": "机器学习基础",
        "chunks": [
            "机器学习是人工智能的一个分支，让计算机能够从数据中学习。",
            "监督学习是最常见的机器学习类型，需要带标签的训练数据。",
            "深度学习使用神经网络，能够处理图像、语音等复杂数据。"
        ],
        "source": "技术文档",
        "category": "人工智能"
    },
    {
        "doc_id": "doc_003",
        "title": "Milvus向量数据库",
        "chunks": [
            "Milvus是一个开源的向量数据库，专为AI应用设计。",
            "Milvus支持多种索引类型，包括IVF、HNSW、DiskANN等。",
            "使用Milvus可以实现毫秒级的向量相似性搜索。"
        ],
        "source": "产品文档",
        "category": "数据库"
    }
]

# ===== 4. 插入数据 =====
print("\n=== 4. 插入数据 ===")

current_time = int(time.time())
inserted_count = 0

for doc in documents:
    for chunk_id, content in enumerate(doc["chunks"]):
        # 模拟生成embedding（实际应该用模型）
        embedding = np.random.rand(768).tolist()
        
        # 构建数据
        data = {
            "embedding": embedding,
            "doc_id": doc["doc_id"],
            "chunk_id": chunk_id,
            "content": content,
            "title": doc["title"],
            "source": doc["source"],
            "category": doc["category"],
            "created_at": current_time,
            "is_active": True,
            "metadata": {
                "word_count": len(content),
                "language": "zh",
                "version": "1.0"
            }
        }
        
        collection.insert([data])
        inserted_count += 1

print(f"✓ 插入 {inserted_count} 条数据")

# ===== 5. 创建索引 =====
print("\n=== 5. 创建索引 ===")

# 向量索引
collection.create_index(
    field_name="embedding",
    index_params={
        "metric_type": "L2",
        "index_type": "IVF_FLAT",
        "params": {"nlist": 64}
    }
)
print("✓ 向量索引创建成功")

# 标量索引（可选，加速过滤）
collection.create_index(
    field_name="category",
    index_params={"index_type": "Trie"}
)
print("✓ 标量索引创建成功")

# 加载Collection
collection.load()
print("✓ Collection已加载")

# ===== 6. 各种查询演示 =====
print("\n=== 6. 查询演示 ===")

# 查询向量
query_embedding = np.random.rand(1, 768).tolist()

# 6.1 纯向量搜索
print("\n6.1 纯向量搜索（找最相似的文档）:")
results = collection.search(
    data=query_embedding,
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 16}},
    limit=3,
    output_fields=["title", "content", "category"]
)
for hits in results:
    for i, hit in enumerate(hits, 1):
        print(f"  {i}. [{hit.entity.get('category')}] {hit.entity.get('title')}")
        print(f"     {hit.entity.get('content')[:50]}...")
        print(f"     距离: {hit.distance:.4f}")

# 6.2 混合查询（向量 + 标量过滤）
print("\n6.2 混合查询（只搜索'人工智能'类别）:")
results = collection.search(
    data=query_embedding,
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 16}},
    limit=3,
    expr='category == "人工智能"',
    output_fields=["title", "content"]
)
for hits in results:
    for hit in hits:
        print(f"  - {hit.entity.get('title')}: {hit.entity.get('content')[:40]}...")

# 6.3 复杂条件查询
print("\n6.3 复杂条件查询（技术文档 + 活跃状态）:")
results = collection.search(
    data=query_embedding,
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 16}},
    limit=5,
    expr='source == "技术文档" and is_active == true',
    output_fields=["title", "content", "category", "source"]
)
for hits in results:
    for hit in hits:
        print(f"  - [{hit.entity.get('source')}] {hit.entity.get('title')}")

# 6.4 纯标量查询
print("\n6.4 纯标量查询（查看所有数据库类别的文档）:")
results = collection.query(
    expr='category == "数据库"',
    output_fields=["doc_id", "title", "content"],
    limit=10
)
for item in results:
    print(f"  - {item['doc_id']}: {item['title']}")
    print(f"    {item['content'][:50]}...")

# 6.5 JSON字段查询
print("\n6.5 JSON字段查询（word_count > 30）:")
results = collection.query(
    expr='metadata["word_count"] > 30',
    output_fields=["title", "content", "metadata"],
    limit=5
)
for item in results:
    print(f"  - {item['title']} (字数: {item['metadata']['word_count']})")

# ===== 7. 更新和删除 =====
print("\n=== 7. 更新和删除演示 ===")

# 删除特定文档
print("\n删除doc_001的所有chunk:")
collection.delete(expr='doc_id == "doc_001"')
print("✓ 删除完成")

# 查看剩余数据
collection.flush()
remaining = collection.query(
    expr="id >= 0",
    output_fields=["doc_id"],
    limit=100
)
unique_docs = set(item['doc_id'] for item in remaining)
print(f"剩余文档: {unique_docs}")

# ===== 8. 数据模型最佳实践总结 =====
print("\n=== 8. 数据模型最佳实践 ===")

best_practices = """
1. 向量字段设计:
   - 一个Collection通常只需要一个向量字段
   - 维度选择：BERT(768)、OpenAI(1536)、自定义模型
   - 合并相关文本生成统一向量

2. 标量字段设计:
   - 高频过滤字段：category、source、created_at
   - 展示字段：title、content（但不要存太长的内容）
   - 关联字段：doc_id（关联外部系统）

3. JSON字段使用:
   - 存储不确定的扩展属性
   - 支持路径访问查询
   - 不要存储核心过滤字段

4. 主键设计:
   - auto_id=True：简单场景
   - auto_id=False：需要关联外部ID

5. 查询优化:
   - 只返回需要的output_fields
   - 合理使用标量索引
   - 复杂过滤条件放在expr中
"""
print(best_practices)

# ===== 9. 清理资源 =====
print("\n=== 9. 清理资源 ===")
collection.release()
# utility.drop_collection(collection_name)
print("✓ 资源已清理")

connections.disconnect("default")
print("✓ 连接已断开")

print("\n🎉 演示完成！")
```

**运行输出示例：**
```
=== 2. 设计RAG文档数据模型 ===
✓ 创建Collection: rag_documents

Schema字段:
  id: DataType.INT64
  embedding: DataType.FLOAT_VECTOR (dim=768)
  doc_id: DataType.VARCHAR (max_length=100)
  chunk_id: DataType.INT64
  content: DataType.VARCHAR (max_length=2000)
  title: DataType.VARCHAR (max_length=200)
  source: DataType.VARCHAR (max_length=100)
  category: DataType.VARCHAR (max_length=50)
  created_at: DataType.INT64
  is_active: DataType.BOOL
  metadata: DataType.JSON

=== 4. 插入数据 ===
✓ 插入 9 条数据

=== 6. 查询演示 ===

6.1 纯向量搜索（找最相似的文档）:
  1. [编程语言] Python入门教程
     Python是一门简单易学的编程语言。它具有清晰的语法和强大的标准库...
     距离: 45.2341

6.2 混合查询（只搜索'人工智能'类别）:
  - 机器学习基础: 机器学习是人工智能的一个分支，让计算机能够从数据中学习...

🎉 演示完成！
```

---

## 8. 【面试必问】

### 问题："如何设计Milvus的数据模型？向量字段和标量字段应该怎么选择？"

**普通回答（❌ 不出彩）：**
"向量字段存Embedding，标量字段存其他数据，想存什么就加什么字段。"

**出彩回答（✅ 推荐）：**

> **Milvus数据模型设计需要考虑三个方面：**
>
> **1. 向量字段设计原则**
> - 通常一个Collection只需要一个向量字段
> - 向量应该是从核心内容（标题+描述+关键词）计算得到的
> - 维度选择取决于Embedding模型：BERT(768)、OpenAI(1536)
> - 多模态场景可以考虑拼接向量或多Collection
>
> **2. 标量字段设计原则**
> - **过滤字段**：category、source、created_at等高频过滤条件
> - **展示字段**：title、summary，但不要存太长的内容
> - **关联字段**：doc_id/product_id，用于关联外部完整数据
> - **不建议存储**：完整正文、大量图片URL、复杂嵌套数据
>
> **3. 与外部系统配合**
> - Milvus存储搜索相关的"精简版"数据
> - MySQL/PostgreSQL存储完整业务数据
> - 搜索流程：Milvus查ID → 外部数据库查完整数据
>
> **实际案例**：我们的RAG系统设计如下：
> ```python
> fields = [
>     id, doc_id, chunk_id,           # 标识
>     embedding(768),                  # 向量
>     title, content(max=2000),        # 展示
>     source, category, created_at,   # 过滤
>     metadata(JSON)                   # 扩展
> ]
> ```
> 这个设计支持：语义搜索、按来源/类别过滤、时间范围查询，满足90%的RAG检索需求。

**为什么这个回答出彩？**
1. ✅ 分类清晰，有设计原则
2. ✅ 说明了什么该存什么不该存
3. ✅ 提到了与外部系统的配合
4. ✅ 有具体的实际案例

---

## 9. 【化骨绵掌】

### 卡片1：数据模型的本质 🎯

**一句话：** 数据模型 = 向量字段 + 标量字段。

**分工：**
- 向量字段：语义搜索
- 标量字段：过滤+展示

**应用：** 实现"智能搜索 + 精确过滤"。

---

### 卡片2：向量字段类型 🔢

**一句话：** 三种向量类型满足不同需求。

| 类型 | 说明 | 场景 |
|-----|------|-----|
| FLOAT_VECTOR | 浮点向量 | 最常用 |
| BINARY_VECTOR | 二进制 | 哈希特征 |
| SPARSE_FLOAT_VECTOR | 稀疏向量 | 稀疏表示 |

**应用：** 大多数场景用FLOAT_VECTOR。

---

### 卡片3：标量字段类型 📝

**一句话：** 支持多种标量类型。

**常用类型：**
- INT64：ID、数量、时间戳
- FLOAT：价格、评分
- VARCHAR：标题、类别
- BOOL：状态标识
- JSON：灵活扩展

**应用：** 根据数据特点选择类型。

---

### 卡片4：混合查询 🔀

**一句话：** 向量搜索 + 标量过滤 = 精准检索。

**代码：**
```python
results = collection.search(
    data=[query_embedding],
    expr='price < 500 and category == "shoes"',
    output_fields=["title", "price"]
)
```

**应用：** 生产环境最常用的查询方式。

---

### 卡片5：过滤表达式 📋

**一句话：** expr支持丰富的条件语法。

**语法：**
```python
# 比较：>, <, >=, <=, ==, !=
# 逻辑：and, or, not
# 范围：in, not in
# 字符串：like "%keyword%"
# JSON：metadata["key"] == "value"
```

**应用：** 组合条件实现复杂过滤。

---

### 卡片6：VARCHAR长度设计 📏

**一句话：** max_length要合理设置。

**方法：**
1. 统计实际数据长度分布
2. 取99%分位数
3. 加20%余量

**注意：** 过大浪费资源，过小数据丢失。

---

### 卡片7：JSON字段用法 📦

**一句话：** JSON字段存储灵活扩展属性。

**代码：**
```python
FieldSchema(name="metadata", dtype=DataType.JSON)

# 插入
data = {"metadata": {"color": "red", "size": [38, 39]}}

# 查询
expr = 'metadata["color"] == "red"'
```

**应用：** 不确定的扩展属性。

---

### 卡片8：与外部系统配合 🔗

**一句话：** Milvus存精简数据，外部存完整数据。

**架构：**
```
Milvus: id + embedding + 过滤字段 + 展示字段
MySQL: id + 完整业务数据

查询流程: Milvus返回ID → MySQL查完整数据
```

**应用：** 减少Milvus存储压力。

---

### 卡片9：Schema设计模板 📄

**一句话：** 通用模板覆盖大多数场景。

**模板：**
```python
fields = [
    # 主键
    id (INT64, primary, auto_id),
    # 向量
    embedding (FLOAT_VECTOR, dim=768),
    # 标识
    doc_id (VARCHAR),
    # 过滤
    category, source, created_at,
    # 展示
    title, content,
    # 扩展
    metadata (JSON)
]
```

**应用：** RAG、搜索、推荐等场景。

---

### 卡片10：数据模型最佳实践 ✨

**一句话：** 四个原则指导数据模型设计。

**原则：**
1. 向量字段尽量少（通常1个）
2. 标量字段按需设计
3. 不存储完整大数据
4. 用JSON存扩展属性

**下一步：** 综合运用Collection、Partition、Index优化性能。

---

## 10. 【一句话总结】

**Milvus数据模型由向量字段和标量字段组成，向量字段存储Embedding实现语义搜索，标量字段存储元数据支持精确过滤，两者配合实现智能且精准的混合检索。**

---

## 📚 学习检查清单

- [ ] 理解向量字段和标量字段的作用
- [ ] 了解支持的数据类型
- [ ] 能够设计符合业务需求的Schema
- [ ] 掌握混合查询的使用方法
- [ ] 理解过滤表达式语法
- [ ] 了解JSON字段的使用场景
- [ ] 理解与外部系统配合的架构

## 🔗 下一步学习

1. **性能优化**：综合使用Collection、Partition、Index
2. **生产部署**：分布式架构和运维
3. **实战项目**：构建完整的RAG系统

## 📖 参考资源

- [Milvus Schema设计](https://milvus.io/docs/schema.md)
- [数据类型说明](https://milvus.io/docs/field-types.md)
- [混合查询指南](https://milvus.io/docs/hybridsearch.md)
